;
; Incomplete disassembly
; Exported from SourceGen using the cc65 mode then some search and replace.
; temporary test build
; Code status
; D000-D3FF is done
; D400-DBFF requires more work
; DC00-DE00 requires more work
;
         cseg 
;         org    0d000h
         .6502
SCRLINEL EQU       $20        ;Address of current line in $400
SCRLINEH EQU       $21        ;Screen address high
ESCAPE_STATE EQU   $22        ;State for ESCAPE leadin
CURSOR_STATE EQU   $23        ;Bit 7 high if cursor on screen
CURSORX  EQU       $25        ;Cursor X (80 col)
ZP_TEMP1 EQU       $26        ;Zero page temporary
D2_CHECK_SUM EQU   $27        ;Checksum for disk routines
CURSORY  EQU       $29        ;Cursor Y (80 col)
HEADER_CHECKSUM EQU $2c       ;Checksum for the sector header
HEADER_SECTOR EQU  $2d
HEADER_TRACK EQU   $2e        ;Track from sector header
HEADER_VOLUME EQU  $2f
MON_INVFLAG EQU    $32        ;text mask (255=normal, 127=flash, 63=inv)
MON_A1H  EQU       $3d        ;general purpose
MON_A2L  EQU       $3e        ;general purpose
MON_A2H  EQU       $3f        ;general purpose
MON_A3H  EQU       $41        ;general purpose
PRODOS_CMD EQU     $42
PRODOS_UNITNUM EQU $43
PRDOOS_BUFPTRL EQU $44
PRODOS_BUFPTRH EQU $45        ;Prodos buffer pointer high
PRODOS_BLKNUM EQU  $46
DISK_TRKL EQU      $0380      ;Disk track low (From Z80)
DISK_SECT EQU      $0381      ;Disk sector (from Z80)
DISK_TRK_ADDR EQU  $0382      ;While track read/write page
DISK_DRV EQU       $0384      ;Drive to use from CPM (Slot)
DISK_ACTD EQU      $0385      ;Current active disk ][ drive
DISK_TRKH EQU      $0386      ;Disk track high (from Z80)
DISK_VOL EQU       $0387      ;Disk volume
DISK_OP  EQU       $0388      ;Disk operation
DISK_ERR EQU       $0389      ;Disk Error back
SLOT_INFO EQU      $03b8
SCRNHOLE0 EQU      $0478      ;text page 1 screen holes
SCRNHOLE1 EQU      $04f8      ;text page 1 screen holes
SCRNHOLE2 EQU      $0578      ;text page 1 screen holes
DISKSLOTCX EQU     $05f8      ;Disk slot $60
SCRNHOLE4 EQU      $0678      ;text page 1 screen holes
SCRNHOLE5 EQU      $06f8      ;text page 1 screen holes
SET80COL EQU       $c001      ;W use PAGE2 for aux mem (80STOREON)
SET80VID EQU       $c00d      ;W enable 80-column display mode
SETALTCHAR EQU     $c00f      ;W use alternate char set
SPKR     EQU       $c030      ;RW toggle speaker
TXTPAGE1 EQU       $c054      ;RW display page 1
TXTPAGE2 EQU       $c055      ;RW display page 2 (or read/write aux mem)
IWM_PH0_OFF EQU    $c080      ;IWM phase 0 off
IWM_MOTOR_OFF EQU  $c088      ;IWM motor off
IWM_MOTOR_ON EQU   $c089      ;IWM motor on
IWM_DRIVE_1 EQU    $c08a      ;IWM select drive 1
IWM_DRIVE_2 EQU    $c08b      ;IWM select drive 2
LCBANK1  EQU       $c08b      ;RWx2 read/write RAM bank 1
IWM_Q6_OFF EQU     $c08c      ;IWM read
IWM_Q6_ON EQU      $c08d      ;IWM WP-sense
IWM_Q7_OFF EQU     $c08e      ;IWM WP-sense/read
IWM_Q7_ON EQU      $c08f      ;IWM write
CLRROM   EQU       $cfff      ;disable slot C8 ROM
SIX_BIT_DATA EQU   $de00      ;Six bit data bytes
TWO_BIT_DATA EQU   $df00      ;56 bytes of 2 bit data

;*******************************************************************************
;*                                                                             *
;* Routines to handle the 80 Column card                                       *
;*                                                                             *
;*******************************************************************************

LD000:   jmp     POP_TOGGLE_CURSOR

PRINT_STACK_CHAR:
         pla                ;Get our character off the stack
PRINT_CHAR:
         ora     #$80       ;Set the high bit
         bit     ESCAPE_STATE
         bpl     CHECK_ESC_CHAR1 ;Bit 7 clear check for escape
         bit     GOTO_Y     ;Goto YX, Y Character set yet?
         bmi     GOTO_YX    ;Must be the X postion now we can move the  cursor
         sta     GOTO_Y     ;Setting the Y character
         rts

; There is a fairly complicated state machine here
; ESCAPE_STATE 
;   Bit 7 0=no escape seen
;   Bit 6 0=Possible normal character
;   Bit 6 1=Escape seen
;   Bit 7 1=Waiting for Y position
; GOTOY
;   Bit 7 0=Not yet seen Y
;   Bit 7 1=Seen Y coord, other bits are Y character.
; 
; So for a <ESC> C where C is a single character escape state goes through
; |Escape state| GOTOY     | 
; |------------|-----------|
; | 00zz zzzz  | 0yyy yyyy | Waiting for escape
; | 01zz zzzz  | 0yyy yyyy | Escape seen waiting next char
; | 00zz zzzz  | 0yyy yyyy | <Esc> C seen C converted to regular ctrl character
; 
; However for <ESC> EQU Y X (goto Y X) the states are as follows
; |Escape state| GOTOY     | 
; |------------|-----------|
; | 00zz zzzz  | 0yyy yyyy | Waiting for escape
; | 01zz zzzz  | 0yyy yyyy | Escape seen waiting next char
; | 11zz zzzz  | 0yyy yyyy | <Esc> EQU seen waiting Y coord
; | 11zz zzzz  | 1yyy yyyy | <Esc> EQU Y seen waiting X Coord
; | 00zz zzzz  | 0yyy yyyy | <Esc> EQU Y X seen cursor moved to correct pos
; 
GOTO_YX: jsr     HIDE_CURSOR
         sec
         sbc     #$a0       ;Subtract space
         cmp     #80        ;Okay are we on screen?
         bcc     CURSORX_OK ;Bigger than screen
         lda     #$00       ;Zero cursor
CURSORX_OK:
         sta     CURSORX    ;Save away X position
         lda     GOTO_Y     ;Get the Y Coord
         sec
         sbc     #$a0
         cmp     #24
         bcc     CURSORY_OK
         lda     #$00
CURSORY_OK:
         sta     CURSORY
         jsr     SET_LINE_PTR
         ldy     #$00
         sty     ESCAPE_STATE
         beq     SHOW_CURSOR

CHECK_ESC_CHAR1:
         bvc     CHECK_FOR_ESC
         jmp     ESCAPE_CHAR1

CHECK_FOR_ESC:
         cmp     #$9b
         bne     CTRL_WRITE_SCR
         lda     #$40
         sta     ESCAPE_STATE
         rts

; Come here to write a character to screen
; and handle control characters
CTRL_WRITE_SCR:
         cmp     #$a0
         bcc     TEST_CONTROL_CHAR ;Go off and deal with a control character
         tax                ;Save A for later
         lda     CURSORX    ;Get the current cursor
         lsr     A          ;Divide by two
         bcs     WRITE_ODD  ;Was it odd
         bit     TXTPAGE2   ;If so write to the odd columns
WRITE_ODD:
         tay                ;Save CursorX/2 -> Y
         txa                ;Get back our character
         and     MON_INVFLAG ;Are we in inverse mode?
         bmi     STORE_TO_SCREEN
         cmp     #$60       ;Inverse lowercase?
         bcs     STORE_TO_SCREEN ;No change needed
         cmp     #$40       ;Inverse Numbers or punctuation?
         bcc     STORE_TO_SCREEN ;No Change needed
         and     #$bf       ;Convert uppercase out of mouse text
STORE_TO_SCREEN:
         sta     (SCRLINEL),y ;Write character to screen
         bit     TXTPAGE1   ;Back to main text page
         inc     CURSORX    ;Move cursor to right
         lda     CURSORX
         cmp     #80        ;Cursor still on screen?
         bcc     SHOW_CURSOR ;Go show it.
         lda     #$00       ;Set us to back to column zero
         sta     CURSORX
         inc     CURSORY    ;Move down a line
         ldy     CURSORY
         cpy     #24        ;Still on screen?
         bcc     NO_SCROLL  ;Yep don't scroll
         dec     CURSORY    ;Correct us
         jsr     SCROLL_UP  ;Scroll the screen up
NO_SCROLL:
         ldy     CURSORY
         lda     LINE_STARTH,y ;Set up the current screen line pointer
         sta     SCRLINEH
         lda     LINE_STARTL,y
         sta     SCRLINEL
SHOW_CURSOR:
         lda     #$80
         sta     CURSOR_STATE ;Set the cursor to on
FLIP_INVERTED:
         lda     CURSORX    ;Get cursor position
         lsr     A
         bcs     CURSOR_PAGE1 ;Which page?
         bit     TXTPAGE2
CURSOR_PAGE1:
         tay                ;Cursor divided by two to Y
         lda     (SCRLINEL),y ;Get the current character on screen
         cmp     #$20       ;Is it an inverse Uppercase
         bcs     INVERT_CHAR ;If not just go and do invert
         ora     #$40       ;Put back bit 6 so it's a proper Uppercase
INVERT_CHAR:
         eor     #$80       ;Invert the character
         bmi     STORE_CURSOR ;Store if it's normal
         cmp     #$60       ;Lower case inverted
         bcs     STORE_CURSOR ;Store it
         cmp     #$40       ;Inverse Numbers or punctuation?
         bcc     STORE_CURSOR ;We're good store it
         and     #$bf       ;Upper case letters, kill bit 6
STORE_CURSOR:
         sta     (SCRLINEL),y ;Store on screen
         bit     TXTPAGE1   ;Back to text page 1
IGNORE_CHAR:
         rts                ;Also used in jump table

; Handle a possible control character
TEST_CONTROL_CHAR:
         cmp     #$9e       ;Off the end of the table
         bcs     IGNORE_CHAR ;Ignore it
         cmp     #$87       ;Off the front of the table
         bcc     IGNORE_CHAR ;Ignore it
HANDLE_CONTROL_CHAR:
         jsr     HIDE_CURSOR
         sec
         sbc     #$87       ;Subtract Bell character
         asl     A          ;Mult by 2 for table index
         tay
         lda     CTRL_CHAR_TAB,y ;Lookup the entry and modify jump
         sta     CTRL_CHAR_JSR+1
         iny
         lda     CTRL_CHAR_TAB,y
         sta     CTRL_CHAR_JSR+2
CTRL_CHAR_JSR:
         jsr     $0000      ;Jump to control handler
         jmp     SHOW_CURSOR

ESCAPE_CHAR1:
         ldy     #$00       ;First character in escape sequence
         sty     ESCAPE_STATE
         cmp     #'=' + $80 ;Goto YX command?
         beq     GOTO_YX_CMD ;Yes it is
; Convert any of the single character escape codes
         ldy     #$05
FIND_ESC_CHAR_LOOP:
         cmp     ESC_CTRL_CODES,y ;Is it in the table?
         beq     FOUND_ESC_CHAR ;Yes it is do something
         dey
         bpl     FIND_ESC_CHAR_LOOP
         jmp     PRINT_CHAR

GOTO_YX_CMD:
         sec                ;Set the high bit so say we're waiting for Y
         ror     ESCAPE_STATE
         clc
         ror     GOTO_Y     ;Clear bit 7 (Seen Y coord)
         rts

FOUND_ESC_CHAR:
         lda     ESC_CHAR_TRANS,y ;Get the regular Ctrl code
         bne     HANDLE_CONTROL_CHAR
; Carriage return
CARRIAGE_RET:
         lda     #$00
         sta     CURSORX
         rts

; Line feed for 80 column
LINEFEED:
         inc     CURSORY
         ldy     CURSORY
         cpy     #24        ;Last line?
         bcc     SET_LINE_PTR ;Nope just set the line pointer
         dec     CURSORY    ;Backup the cursor
         jsr     SCROLL_UP  ;Scroll up
SET_LINE_PTR:
         ldy     CURSORY    ;Lookup new line pointer
         lda     LINE_STARTH,y
         sta     SCRLINEH   ;And save it away
         lda     LINE_STARTL,y
         sta     SCRLINEL
         rts

POP_TOGGLE_CURSOR:
         pla                ;Pop unwanted parameter
TOGGLE_CURSOR:
         lda     CURSOR_STATE ;Flip the cursor state
         eor     #$80
         sta     CURSOR_STATE
         jmp     FLIP_INVERTED ;Flip the character on screen inverse state

; Backspace
BACKSPACE:
         dec     CURSORX    ;Decrement the cursor position
         bmi     OFF_LEFT   ;Off left hand of screen?
         rts                ;Go Home still on screen

OFF_LEFT:
         lda     #79        ;Right hand edge of screen
         sta     CURSORX
         dec     CURSORY    ;Back up a line
         bpl     SET_LINE_PTR ;Still on screen set pointer
         lda     #$00
         sta     CURSORY    ;Top line of screen
         jsr     SCROLL_CARRY_FLAG ;Scroll depending on state of carry flage
         jmp     SET_LINE_PTR

; Cursor Right
CURSOR_RIGHT:
         inc     CURSORX    ;Add one to cursor position
         lda     CURSORX
         cmp     #80        ;Off right hand edge
         bcs     OFF_RIGHT
         rts                ;Nope go home

OFF_RIGHT:
         jsr     CARRIAGE_RET ;Off right hand edge Set to 0
         jmp     LINEFEED   ;and down a line

; Clear line
CLR_LINE:
         lda     #$00       ;Set us to be at the beginning of the line
         sta     CURSORX
         jmp     CLR_EOL    ;Now clear to EOL

; Home
HOME:    ldy     #$00       ;Set Cursor X,Y to 0,0
         sty     CURSORX
         sty     CURSORY
         jmp     SET_LINE_PTR ;Set the current line pointer

; Clear to end of screen
CLR_TO_ENDSCR:
         jsr     CLR_EOL
         lda     SCRLINEL   ;Save away current screen position
         pha
         lda     SCRLINEH
         pha
         ldx     CURSORY    ;Get line number
CLR_NEXT_LINE:
         inx
         cpx     #24
         bne     CLR_LINE_X ;Go and clear this line
         pla
         sta     SCRLINEH
         pla
         sta     SCRLINEL
         rts

CLR_LINE_X:
         lda     LINE_STARTH,x
         sta     SCRLINEH
         lda     LINE_STARTL,x
         sta     SCRLINEL
         ldy     #$00
         jsr     CLR_FROM_YREG
         beq     CLR_NEXT_LINE ;Zero flag always set back into loop
; Clear the screen and initialise the 
; video system
CLEAR_SCREEN:
         sta     TXTPAGE1   ;Setup the //e hardware
         sta     SETALTCHAR
         sta     SET80VID
         sta     SET80COL
         lda     #$00       ;Set X,Y to zero
         sta     CURSORX
         sta     CURSORY
         sta     SCRLINEL   ;Set the screen ptr up
         lda     #$04
         sta     SCRLINEH
         bne     CLR_TO_ENDSCR

; Clear to end of line
CLR_EOL: ldy     CURSORX    ;Clear to EOL
CLR_FROM_YREG:
         bit     TXTPAGE2
         tya                ;Divide cursor by two
         lsr     A
         pha                ;Save cursor/2 for Page 1 clear
         tay
         lda     #$a0       ;Sort out if blank is inverse or not
         and     MON_INVFLAG
         sta     ZP_TEMP1   ;Save our blank character
         bcs     SKIP_ODD_CLR ;Do we need skip the first one?
CLR_PAGE2_LINE:
         sta     (SCRLINEL),y ;Clear the character
SKIP_ODD_CLR:
         iny                ;Next one
         cpy     #40        ;All Done?
         bne     CLR_PAGE2_LINE ;Nah loop
         pla                ;Restore cursor/2 for page 1 clear
         tay
         lda     ZP_TEMP1   ;Get the character to clear with
         bit     TXTPAGE1   ;Setup for main text page
CLR_PAGE1_LINE:
         sta     (SCRLINEL),y ;Clear the character
         iny                ;Next one
         cpy     #40        ;All done?
         bne     CLR_PAGE1_LINE ;Nope do the next one
         rts

; Ring the bell
BELL:    lda     #$35
         sta     BELL_COUNT
BELL_LOOP:
         lda     #$05
         jsr     DELAY
         sta     SPKR
         lda     #$20
         jsr     DELAY
         sta     SPKR
         dec     BELL_COUNT
         bne     BELL_LOOP
         rts

DELAY:   sec
DELAY1:  pha                ;Save counter
DELAY2:  sbc     #$01       ;Decrement our counter
         bne     DELAY2     ;Inner loop
         pla                ;Get counter back for the outer loop
         sbc     #$01
         bne     DELAY1     ;All done yet?
         rts

BELL_COUNT:
         DB   $00

SET_INVERSE:
         lda     #$7f
         bne     STORE_INVFLAG

SET_NORMAL:
         lda     #$ff
STORE_INVFLAG:
         sta     MON_INVFLAG
         rts

SCROLL_UP:
         sec
; Come in here with carry flag set to scroll up
; carry flag clear to scroll down
SCROLL_CARRY_FLAG:
         DB   $24        ;BIT Zero page
SCROLL_DOWN:
         clc
         lda     #$a0       ;Space character
         and     MON_INVFLAG ;Should it be inverted?
         tay
         ldx     #39        ;Bytes to move
SCROLL_LOOP:
         sta     TXTPAGE2   ;Do half the 80 columns
         jsr     SCROLL_COLUMN
         sta     TXTPAGE1
         jsr     SCROLL_COLUMN ;Do the other half
         dex
         bpl     SCROLL_LOOP ;Done all 40?
         rts

SCROLL_COLUMN:
         bcs     SCROLL_COL_UP ;Scroll a single column
         jmp     SCROLL_COL_DOWN

SCROLL_COL_UP:
         lda     $0480,x    ;Copy line by line
         sta     $0400,x
         lda     $0500,x
         sta     $0480,x
         lda     $0580,x
         sta     $0500,x
         lda     $0600,x
         sta     $0580,x
         lda     $0680,x
         sta     $0600,x
         lda     $0700,x
         sta     $0680,x
         lda     $0780,x
         sta     $0700,x
         lda     $0428,x
         sta     $0780,x
         lda     $04a8,x
         sta     $0428,x
         lda     $0528,x
         sta     $04a8,x
         lda     $05a8,x
         sta     $0528,x
         lda     $0628,x
         sta     $05a8,x
         lda     $06a8,x
         sta     $0628,x
         lda     $0728,x
         sta     $06a8,x
         lda     $07a8,x
         sta     $0728,x
         lda     $0450,x
         sta     $07a8,x
         lda     $04d0,x
         sta     $0450,x
         lda     $0550,x
         sta     $04d0,x
         lda     $05d0,x
         sta     $0550,x
         lda     $0650,x
         sta     $05d0,x
         lda     $06d0,x
         sta     $0650,x
         lda     $0750,x
         sta     $06d0,x
         lda     $07d0,x
         sta     $0750,x
         tya                ;Blank character in Y
         sta     $07d0,x
         rts

SCROLL_COL_DOWN:
         lda     $0750,x    ;copy lines up
         sta     $07d0,x
         lda     $06d0,x
         sta     $0750,x
         lda     $0650,x
         sta     $06d0,x
         lda     $05d0,x
         sta     $0650,x
         lda     $0550,x
         sta     $05d0,x
         lda     $04d0,x
         sta     $0550,x
         lda     $0450,x
         sta     $04d0,x
         lda     $07a8,x
         sta     $0450,x
         lda     $0728,x
         sta     $07a8,x
         lda     $06a8,x
         sta     $0728,x
         lda     $0628,x
         sta     $06a8,x
         lda     $05a8,x
         sta     $0628,x
         lda     $0528,x
         sta     $05a8,x
         lda     $04a8,x
         sta     $0528,x
         lda     $0428,x
         sta     $04a8,x
         lda     $0780,x
         sta     $0428,x
         lda     $0700,x
         sta     $0780,x
         lda     $0680,x
         sta     $0700,x
         lda     $0600,x
         sta     $0680,x
         lda     $0580,x
         sta     $0600,x
         lda     $0500,x
         sta     $0580,x
         lda     $0480,x
         sta     $0500,x
         lda     $0400,x
         sta     $0480,x
         tya
         sta     $0400,x
         rts

HIDE_CURSOR:
         bit     CURSOR_STATE ;Get the current cursor state
         bpl     CURSOR_IS_OFF ;Is it off
         pha                ;Nope save the accumulator
         jsr     TOGGLE_CURSOR ;Toggle the cursor
         pla                ;Restore acc
CURSOR_IS_OFF:
         rts

CTRL_CHAR_TAB:
         DW   BELL       ;Ctrl-G
         DW   BACKSPACE  ;Ctrl-H
         DW   IGNORE_CHAR ;Ctrl-I
         DW   LINEFEED   ;Ctrl-J
         DW   CLR_TO_ENDSCR ;Ctrl-K
         DW   CLEAR_SCREEN ;Ctrl-L
         DW   CARRIAGE_RET ;Ctrl-M
         DW   SET_NORMAL ;Ctrl-N
         DW   SET_INVERSE ;Ctrl-O
         DW   IGNORE_CHAR ;Ctrl-P
         DW   IGNORE_CHAR ;Ctrl-Q
         DW   IGNORE_CHAR ;Ctrl-R
         DW   IGNORE_CHAR ;Ctrl-S
         DW   IGNORE_CHAR ;Ctrl-T
         DW   IGNORE_CHAR ;Ctrl-U
         DW   SCROLL_DOWN ;Ctrl-V
         DW   SCROLL_UP  ;Ctrl-W
         DW   IGNORE_CHAR ;Ctrl-X
         DW   HOME       ;Ctrl-Y
         DW   CLR_LINE   ;Ctrl-Z
         DW   IGNORE_CHAR ;Ctrl-[ aka Esc
         DW   CURSOR_RIGHT ;Ctrl-\
         DW   CLR_EOL    ;Ctrl-]
LINE_STARTH:
         DB   $04,$04,$05,$05,$06,$06,$07,$07 ;Start of video line high
         DB   $04,$04,$05,$05,$06,$06,$07,$07
         DB   $04,$04,$05,$05,$06,$06,$07,$07
LINE_STARTL:
         DB   $00,$80,$00,$80,$00,$80,$00,$80 ;Start of video line low
         DB   $28,$a8,$28,$a8,$28,$a8,$28,$a8
         DB   $50,$d0,$50,$d0,$50,$d0,$50,$d0
; Used to convert some televideo 920(maybe?) escape codes to Ctrl codes
ESC_CTRL_CODES:
         DB   $8c        ;<ESC><FF> - Form feed
         DB   ')' + $80  ;<ESC> ) - Start half intensity
         DB   '(' + $80  ;<ESC> ( - End half intesity
         DB   '*' + $80  ;<ESC> * - Clear all to null
         DB   'Y' + $80  ;<ESC> Y - Page erase to space
         DB   'T' + $80  ;<ESC> T - Line erase to space
ESC_CHAR_TRANS:
         DB   $8c        ;Ctrl-L - Form feed
         DB   $8e        ;Ctrl-N - set normal
         DB   $8f        ;Ctrl-O - Set Inverse
         DB   $8c        ;Ctrl-L - Form feed
         DB   $8b        ;Ctrl-K - Clear to end of screen
         DB   $9d        ;Ctrl-] - Clear to end of line
GOTO_Y:  DB   $00        ;Goto YX cursor Y
         DS    90,$1a

;*******************************************************************************
;*                                                                             *
;* Routines to handle Disk drives                                              *
;*                                                                             *
;*******************************************************************************
         lda     DISK_DRV   ;Get the drive ($60 for S6,D1)
         and     #$7f       ;Mask off drive (ProDOS style)
         sta     DISKSLOTCX
         lsr     A
         lsr     A
         lsr     A
         lsr     A
         tax
         lda     SLOT_INFO,x ;Get Disk type? Might be card in slot
         cmp     #$02       ;DISK ][ ?
         beq     DISKII
         cmp     #$07
         bcc     BAD_SLOT_ERR
         jmp     IDC_CHECK

BAD_SLOT_ERR:
         lda     #$01
         sta     DISK_ERR
         rts

;*******************************************************************************
;*                                                                             *
;* Disk II driver code                                                         *
;*                                                                             *
;*******************************************************************************
DISKII:  ldy     #$02
         sty     SCRNHOLE5
         ldy     #$04
         sty     SCRNHOLE1
         ldx     DISKSLOTCX
         lda     IWM_Q7_OFF,x ;Into read mode
         lda     IWM_Q6_OFF,x
         ldy     #$08
CHECK_FOR_DATA:
         lda     IWM_Q6_OFF,x ;Read some data
         pha                ;Waste 3+4 cycles
         pla
         pha                ;Waste 3+4 cycles
         pla
         cmp     IWM_Q6_OFF,x ;Read some data
         bne     DATA_INCOMING
         dey
         bne     CHECK_FOR_DATA
DATA_INCOMING:
         php                ;Zero flag set means data incoming
         lda     IWM_MOTOR_ON,x
         lda     #$ef
         sta     PRODOS_BLKNUM
         lda     #$d8
         sta     PRODOS_BLKNUM+1
         lda     DISK_DRV   ;Get selected drive
         cmp     DISK_ACTD  ;Same as active drive
         beq     SELECT_DRIVE
         sta     DISK_ACTD  ;Update the drive
         plp
         ldy     #$00       ;Clear zero flag
         php
SELECT_DRIVE:
         rol     A
         bcs     SELECT_DRIVE2
         lda     IWM_DRIVE_1,x
         bcc     LD46B

SELECT_DRIVE2:
         lda     IWM_DRIVE_2,x
LD46B:   ror     $35
         plp
         php
         bne     XLD47C
         ldy     #$07
XLD473:  jsr     LD6D9
         dey
         bne     XLD473
         ldx     DISKSLOTCX
XLD47C:  lda     DISK_OP
         cmp     #$03
         bne     XLD487
         plp
         jmp     LD9B3

XLD487:  lda     DISK_TRKL
         jsr     MOVE_TO_TRACK
         lda     DISK_OP
         plp
         bne     XLD49A
         cmp     #$01       ;Read?
         beq     XLD49A
         jsr     LD8C4
XLD49A:  cmp     #$04       ;Read multiple sectors
         bne     XLD4A1
         jmp     LDA1A

XLD4A1:  cmp     #$05
         bne     LD4A8
         jmp     LDA1A

LD4A8:   ror     A
         php
         bcs     LD4AF
         jsr     NIBBLIZE62
LD4AF:   ldy     #$30
         sty     SCRNHOLE2
LD4B4:   ldx     DISKSLOTCX
         jsr     D2_READ_HEADER
         bcc     LD4DE
LD4BC:   dec     SCRNHOLE2
         bpl     LD4B4
LD4C1:   lda     #$2a
         jsr     LD6EE
         dec     SCRNHOLE5
         beq     LD4FC
         lda     #$04
         sta     SCRNHOLE1
         lda     #$00
         jsr     MOVE_TO_TRACK
         lda     DISK_TRKL
LD4D8:   jsr     MOVE_TO_TRACK
         jmp     LD4AF

LD4DE:   lda     HEADER_VOLUME
         sta     DISK_VOL
         pha
         pla
         ldy     HEADER_TRACK
         cpy     DISK_TRKL
         beq     LD502
         lda     SCRNHOLE0
         pha
         tya
         jsr     LD6EE
         pla
         dec     SCRNHOLE1
         bne     LD4D8
         beq     LD4C1

LD4FC:   lda     #$01
         plp
         sec
LD500:   bcs     DISKII_ERR

LD502:   lda     DISK_SECT
         tay
LD506:   lda     CPM_TRAN_SECT,y
         cmp     HEADER_SECTOR
         bne     LD4BC
         plp
         bcc     LD52B
         jsr     D2_READ_SECTOR_DATA
         php
         bcs     LD4BC
         plp
         ldx     #$00
         stx     ZP_TEMP1
         jsr     MERGE62
         ldx     DISKSLOTCX
DISKII_OK:
         lda     #$00       ;Clear error
         clc
DISKII_ERR:
         sta     DISK_ERR   ;Setup disk error
         lda     IWM_MOTOR_OFF,x ;Turn off motor
         rts

LD52B:   jsr     D2_WRITE_SECTOR_DATA
         bcc     DISKII_OK
         lda     #$10
         sec
         bcs     DISKII_ERR

CPM_TRAN_SECT:
         DB   $00,$03,$06,$09,$0c,$0f,$02,$05
         DB   $08,$0b,$0e,$01,$04,$07,$0a,$0d
LD545:   DB   $70
         DB   $2c
         DB   $26
         DB   $22
         DB   $1f
         DB   $1e
         DB   $1d
         DS    6,$1c
TRANS62: DB   $96,$97,$9a,$9b,$9d,$9e,$9f,$a6
         DB   $a7,$ab,$ac,$ad,$ae,$af,$b2,$b3
         DB   $b4,$b5,$b6,$b7,$b9,$ba,$bb,$bc
         DB   $bd,$be,$bf,$cb,$cd,$ce,$cf,$d3
         DB   $d6,$d7,$d9,$da,$db,$dc,$dd,$de
         DB   $df,$e5,$e6,$e7,$e9,$ea,$eb,$ec
         DB   $ed,$ee,$ef,$f2,$f3,$f4,$f5,$f6
         DB   $f7,$f9,$fa,$fb,$fc,$fd,$fe,$ff
         DB   $00,$00,$00,$00,$00,$01
         DB   $98,$99,$02,$03,$9c,$04,$05,$06
         DB   $a0,$a1,$a2,$a3,$a4,$a5,$07,$08
         DB   $a8,$a9,$aa,$09,$0a,$0b,$0c,$0d
         DB   $b0,$b1,$0e,$0f,$10,$11,$12,$13
         DB   $b8,$14,$15,$16,$17,$18,$19,$1a
         DB   $c0,$c1,$c2,$c3,$c4,$c5,$c6,$c7
         DB   $c8,$c9,$ca,$1b,$cc,$1c,$1d,$1e
         DB   $d0,$d1,$d2,$1f,$d4,$d5,$20,$21
         DB   $d8,$22,$23,$24,$25,$26,$27,$28
         DB   $e0,$e1,$e2,$e3,$e4,$29,$2a,$2b
         DB   $e8,$2c,$2d,$2e,$2f,$30,$31,$32
         DB   $f0,$f1,$33,$34,$35,$36,$37,$38
         DB   $f8,$39,$3a,$3b,$3c,$3d,$3e,$3f
D2_WRITE_SECTOR_DATA:
         sec
         stx     D2_CHECK_SUM
         stx     SCRNHOLE4
         lda     IWM_Q6_ON,x
         lda     IWM_Q7_OFF,x
         bmi     XLD68A
         lda     TWO_BIT_DATA
         sta     ZP_TEMP1
         lda     #$ff       ;Write sync bytes
         sta     IWM_Q7_ON,x
         ora     IWM_Q6_OFF,x
         pha
         pla
         nop
         ldy     #$04
XLD620:  pha
         pla
         jsr     WRITE7
         dey
         bne     XLD620
; data header
         lda     #$d5       ;Write data header bytes
         jsr     WRITE9
         lda     #$aa
         jsr     WRITE9
         lda     #$ad
         jsr     WRITE9
         tya
         ldy     #$56
         bne     XLD63F

XLD63C:  lda     TWO_BIT_DATA,y
XLD63F:  eor     TWO_BIT_DATA-1,y
         tax
         lda     TRANS62,x
         ldx     D2_CHECK_SUM
         sta     IWM_Q6_ON,x
         lda     IWM_Q6_OFF,x
         dey
         bne     XLD63C
         lda     ZP_TEMP1
         nop
XLD654:  eor     SIX_BIT_DATA,y
         tax
         lda     TRANS62,x
         ldx     SCRNHOLE4
         sta     IWM_Q6_ON,x
         lda     IWM_Q6_OFF,x
         lda     SIX_BIT_DATA,y
         iny
         bne     XLD654
         tax
         lda     TRANS62,x
         ldx     D2_CHECK_SUM
         jsr     WRITE      ;Write checksum
         lda     #$de       ;Write trailer bytes
         jsr     WRITE9
         lda     #$aa
         jsr     WRITE9
         lda     #$eb
         jsr     WRITE9
         lda     #$ff
         jsr     WRITE9
         lda     IWM_Q7_OFF,x
XLD68A:  lda     IWM_Q6_OFF,x
         rts

NIBBLIZE62:
         ldx     #$55
         lda     #$00
XLD692:  sta     TWO_BIT_DATA,x
         dex
         bpl     XLD692
         tay
         ldx     #$ac
         DB   $2c

LD69C:   ldx     #$aa
LD69E:   dey
LD69F:   lda     $0800,y
         lsr     A
         rol     $de56,x
         lsr     A
         rol     $de56,x
         sta     SIX_BIT_DATA,y
         inx
         bne     LD69E
         tya
         bne     LD69C
         rts

; Write data every 32 cycles
; 
; Typical call sequence
;   2 2 cycles - LDA #D5
;   8 6 cycles - JSR WRITE9
;  10 2 cycles - CLC
;  13 3 cycles - PHA
;  17 4 cycles - PLA
;  22 5 cycles - STA $C08B,x
;  26 4 cycles - ORA $C08C,X
;  32 6 cycles - RTS
WRITE9:  clc                ;2 Cycles - Provide different delays
WRITE7:  pha                ;3 cycles - delays to produce
         pla                ;4 cycles correct timeing
WRITE:   sta     IWM_Q6_ON,x ;5 cycles - Write load
         ora     IWM_Q6_OFF,x ;5 cycles - write byte
         rts                ;6 cycles - return to caller 

MERGE62: ldy     #$00       ;Merge together 6 and 2 bits
RESET2PTR:
         ldx     #$56
MERGE_NXTBYTE:
         dex
         bmi     RESET2PTR
         lda     SIX_BIT_DATA,y
         lsr     TWO_BIT_DATA,x
         rol     A
         lsr     TWO_BIT_DATA,x
         rol     A
LD6D0:   sta     $0800,y
         iny
         cpy     ZP_TEMP1
         bne     MERGE_NXTBYTE
         rts

LD6D9:   ldx     #$11
XLD6DB:  dex
         bne     XLD6DB
         inc     PRODOS_BLKNUM
         bne     XLD6E8
         inc     $47
         bne     XLD6E8
         dec     $47
XLD6E8:  sec
         sbc     #$01
         bne     LD6D9
         rts

LD6EE:   pha
         lda     DISK_DRV
         rol     A
         ror     $35
         jsr     SLOT_TO_Y
         pla
         asl     A
         bit     $35
         bmi     XLD703
         sta     SCRNHOLE1,y
         bpl     XLD706

XLD703:  sta     SCRNHOLE0,y
XLD706:  rts

D2_READ_SECTOR_DATA:
         ldy     #$20       ;Try to find a D5 32 times (we've seen a sector header)
D2_READ_SECT_RETRY:
         dey
         beq     SEC_AND_RET
D2_READ_SECT_D5:
         lda     IWM_Q6_OFF,x
         bpl     D2_READ_SECT_D5
D2_WAIT_SECT_D5:
         eor     #$d5       ;Look for D5 (and zero ACC)
         bne     D2_READ_SECT_RETRY ;Not yet try again
         nop
D2_READ_SECT_AA:
         lda     IWM_Q6_OFF,x ;Try and read AA
         bpl     D2_READ_SECT_AA
         cmp     #$aa       ;Not AA, wait for a D5
         bne     D2_WAIT_SECT_D5
         ldy     #$56       ;Setup to read in 56 bytes of twos
D2_READ_SECT_AD:
         lda     IWM_Q6_OFF,x
         bpl     D2_READ_SECT_AD
         cmp     #$ad       ;End of header?
         bne     D2_WAIT_SECT_D5 ;Nope, lets start again
         lda     #$00
D2_READ_2BYTES:
         dey
         sty     ZP_TEMP1   ;Save away counter
D2_WAIT_2BYTES:
         ldy     IWM_Q6_OFF,x ;Read a data byte for our 2 bits
         bpl     D2_WAIT_2BYTES
         eor     LD500,y
         ldy     ZP_TEMP1   ;Restore counter
         sta     TWO_BIT_DATA,y
         bne     D2_READ_2BYTES
D2_READ_6BYTES:
         sty     ZP_TEMP1   ;Save counter
D2_WAIT_6BYES:
         ldy     IWM_Q6_OFF,x
         bpl     D2_WAIT_6BYES
         eor     LD500,y
         ldy     ZP_TEMP1
         sta     SIX_BIT_DATA,y
         iny
         bne     D2_READ_6BYTES
XLD750:  ldy     IWM_Q6_OFF,x
         bpl     XLD750
         cmp     LD500,y
         bne     SEC_AND_RET
XLD75A:  lda     IWM_Q6_OFF,x
         bpl     XLD75A
         cmp     #$de
         bne     SEC_AND_RET
         nop
XLD764:  lda     IWM_Q6_OFF,x
         bpl     XLD764
         cmp     #$aa
         beq     LD7C9
SEC_AND_RET:
         sec                ;Set carry flag and return
         rts

D2_READ_HEADER:
         ldy     #$fc
         sty     ZP_TEMP1
D2_WAIT_HEADER:
         iny
         bne     D2_READ_HEAD_D5
         inc     ZP_TEMP1
         beq     SEC_AND_RET
D2_READ_HEAD_D5:
         lda     IWM_Q6_OFF,x
         bpl     D2_READ_HEAD_D5
D2_WAIT_FOR_D5:
         cmp     #$d5
         bne     D2_WAIT_HEADER
         nop
D2_READ_HEAD_AA:
         lda     IWM_Q6_OFF,x
         bpl     D2_READ_HEAD_AA
         cmp     #$aa
         bne     D2_WAIT_FOR_D5
         ldy     #$03       ;Setup counter for header bytes
D2_READ_HEAD_96:
         lda     IWM_Q6_OFF,x
         bpl     D2_READ_HEAD_96
         cmp     #$96       ;Last byte of header?
         bne     D2_WAIT_FOR_D5 ;Nope loop back to beginning
         lda     #$00       ;Reset checksum byte
READ_NXT_HDR_BYTE:
         sta     D2_CHECK_SUM
WAIT_44_BYTE1:
         lda     IWM_Q6_OFF,x ;Read first byte of our 44 encoding
         bpl     WAIT_44_BYTE1 ;Read in 1A1C1E1G
         rol     A          ;A1C1E1G1 (Carry is set by CMP #96)
         sta     ZP_TEMP1   ;Save for later
WAIT_44_BYTE2:
         lda     IWM_Q6_OFF,x
         bpl     WAIT_44_BYTE2 ;Read in  1B1D1F1H
         and     ZP_TEMP1   ;And with A1C1E1G1
         sta     HEADER_CHECKSUM,y ;Store away the data
         eor     D2_CHECK_SUM
         dey                ;Count backwards
         bpl     READ_NXT_HDR_BYTE ;Done all four bytes
         tay
         bne     SEC_AND_RET
XLD7B6:  lda     IWM_Q6_OFF,x
         bpl     XLD7B6
         cmp     #$de
         bne     SEC_AND_RET
         nop
XLD7C0:  lda     IWM_Q6_OFF,x
         bpl     XLD7C0
         cmp     #$aa
         bne     SEC_AND_RET
LD7C9:   clc
         rts

MOVE_TO_TRACK:
         asl     A          ;MOVE_TO_TRACK
         jsr     XLD7D3
         lsr     SCRNHOLE0
         rts

XLD7D3:  sta     $2a
         jsr     SLOT_TO_Y
         lda     SCRNHOLE0,y
         bit     $35
         bmi     XLD7E2
         lda     SCRNHOLE1,y
XLD7E2:  sta     SCRNHOLE0
         lda     $2a
         bit     $35
         bmi     XLD7F0
         sta     SCRNHOLE1,y
         bpl     XLD7F3

XLD7F0:  sta     SCRNHOLE0,y
XLD7F3:  stx     $2b
         sta     $2a
         cmp     SCRNHOLE0
         beq     XLD84F
         lda     #$00
         sta     ZP_TEMP1
XLD800:  lda     SCRNHOLE0
         sta     D2_CHECK_SUM
         sec
         sbc     $2a
         beq     XLD83D
         bcs     XLD813
         eor     #$ff
         inc     SCRNHOLE0
         bcc     XLD818

XLD813:  adc     #$fe
         dec     SCRNHOLE0
XLD818:  cmp     ZP_TEMP1
         bcc     XLD81E
         lda     ZP_TEMP1
XLD81E:  cmp     #$0c
         bcs     XLD823
         tay
XLD823:  sec
         jsr     XLD841
         lda     LDA8E,y
         jsr     LD6D9
         lda     D2_CHECK_SUM
         clc
         jsr     XLD844
         lda     LD545,y
         jsr     LD6D9
         inc     ZP_TEMP1
         bne     XLD800
XLD83D:  jsr     LD6D9
         clc
XLD841:  lda     SCRNHOLE0
XLD844:  and     #$03
         rol     A
         ora     $2b
         tax
         lda     IWM_PH0_OFF,x
         ldx     $2b
XLD84F:  rts

LD850:   lda     IWM_Q6_OFF,x
         lda     #$10
         sec
         rts

LD857:   lda     IWM_Q6_ON,x
         lda     IWM_Q7_OFF,x
         bmi     LD850
         lda     #$ff
         sta     IWM_Q7_ON,x
         cmp     IWM_Q6_OFF,x
         pha
         pla
XLD869:  jsr     XLD8C3
         jsr     XLD8C3
         sta     IWM_Q6_ON,x
         cmp     IWM_Q6_OFF,x
         nop
         dey
         bne     XLD869
         lda     #$d5
         jsr     LD8E3
         lda     #$aa
         jsr     LD8E3
         lda     #$96
         jsr     LD8E3
         lda     MON_A3H
         jsr     LD8D2
         lda     PRDOOS_BUFPTRL
         jsr     LD8D2
         lda     MON_A2H
         jsr     LD8D2
         lda     MON_A3H
         eor     PRDOOS_BUFPTRL
         eor     MON_A2H
         pha
         lsr     A
         ora     MON_A2L
         sta     IWM_Q6_ON,x
         lda     IWM_Q6_OFF,x
         pla
         ora     #$aa
         jsr     LD8E2
         lda     #$de
         jsr     LD8E3
         lda     #$aa
         jsr     LD8E3
         lda     #$eb
         jsr     LD8E3
         clc
         lda     IWM_Q7_OFF,x
         lda     IWM_Q6_OFF,x
XLD8C3:  rts

LD8C4:   ldy     #$12
XLD8C6:  dey
         bne     XLD8C6
         inc     PRODOS_BLKNUM
         bne     LD8C4
         inc     $47
         bne     LD8C4
         rts

LD8D2:   pha
         lsr     A
         ora     MON_A2L
         sta     IWM_Q6_ON,x
         cmp     IWM_Q6_OFF,x
         pla
         nop
         nop
         nop
         ora     #$aa
LD8E2:   nop
LD8E3:   nop
         pha
         pla
         sta     IWM_Q6_ON,x
         cmp     IWM_Q6_OFF,x
LD8EC:   rts

         ldx     #$07
XLD8EF:  cpx     #$06
         beq     XLD8F8
         cmp     SLOT_INFO,x
         beq     XLD900
XLD8F8:  dex
         bne     XLD8EF
         pla
         pla
         jmp     SET_DISK_ERR1

XLD900:  txa
         asl     A
         asl     A
         asl     A
         asl     A
         rts

         DB   $00,$02,$04,$06,$08,$0a,$0c,$0e
         DB   $01,$03,$05,$07,$09,$0b,$0d,$0f

LD916:   lda     #$00
         sta     MON_A2H
         ldy     #$80
         bne     XLD920

XLD91E:  ldy     PRODOS_BUFPTRH
XLD920:  jsr     LD857
         bcs     LD8EC
         jsr     D2_WRITE_SECTOR_DATA
         nop
         nop
         inc     MON_A2H
         lda     MON_A2H
         cmp     #$10
         bcc     XLD91E
         ldy     #$0f
         sty     MON_A2H
         lda     #$30
         sta     SCRNHOLE2
XLD93B:  sta     $df57,y
         dey
         bpl     XLD93B
         ldy     PRODOS_BUFPTRH
XLD943:  jsr     XLD991
         jsr     XLD991
         jsr     XLD991
         pha
         pla
         nop
         dey
         bne     XLD943
         jsr     D2_READ_HEADER
         bcs     XLD97A
         lda     HEADER_SECTOR
         beq     XLD970
         lda     #$10
         cmp     PRODOS_BUFPTRH
         lda     PRODOS_BUFPTRH
         sbc     #$01
         sta     PRODOS_BUFPTRH
         cmp     #$05
         bcs     XLD97A
         bcc     XLD98F

XLD96B:  jsr     D2_READ_HEADER
         bcs     XLD975
XLD970:  jsr     D2_READ_SECTOR_DATA
         bcc     XLD993
XLD975:  dec     SCRNHOLE2
         bne     XLD96B
XLD97A:  jsr     D2_READ_HEADER
         bcs     XLD98A
         lda     HEADER_SECTOR
         cmp     #$0f
         bne     XLD98A
         jsr     D2_READ_SECTOR_DATA
         bcc     LD916
XLD98A:  dec     SCRNHOLE2
         bne     XLD97A
XLD98F:  lda     #$01
XLD991:  sec
XLD992:  rts

XLD993:  ldy     HEADER_SECTOR
         lda     $df57,y
         bmi     XLD975
         lda     #$ff
         sta     $df57,y
         dec     MON_A2H
         bpl     XLD96B
         lda     PRDOOS_BUFPTRL
         bne     XLD9B1
         lda     PRODOS_BUFPTRH
         cmp     #$10
         bcc     XLD992
         dec     PRODOS_BUFPTRH
         dec     PRODOS_BUFPTRH
XLD9B1:  clc
         rts

LD9B3:   jsr     LD8C4
         lda     DISK_VOL
         sta     MON_A3H
         lda     #$aa
         sta     MON_A2L
         ldy     #$56
         lda     #$00
         sta     PRDOOS_BUFPTRL
         lda     #$2a
XLD9C7:  sta     TWO_BIT_DATA-1,y
         dey
         bne     XLD9C7
         lda     #$39
XLD9CF:  sta     SIX_BIT_DATA,y
         dey
         bne     XLD9CF
         lda     #$23
         sta     MON_A1H
         lda     #$2a
         jsr     LD6EE
         lda     #$28
         sta     PRODOS_BUFPTRH
XLD9E2:  lda     PRDOOS_BUFPTRL
         jsr     MOVE_TO_TRACK
         jsr     LD916
         bcs     XLDA13
         lda     #$30
         sta     SCRNHOLE2
XLD9F1:  sec
         dec     SCRNHOLE2
         beq     XLDA11
         jsr     D2_READ_HEADER
         bcs     XLD9F1
         lda     HEADER_SECTOR
         bne     XLD9F1
         jsr     D2_READ_SECTOR_DATA
         bcs     XLD9F1
         inc     PRDOOS_BUFPTRL
         lda     MON_A1H
         cmp     PRDOOS_BUFPTRL
         bne     XLD9E2
         lda     #$00
         beq     XLDA13

XLDA11:  lda     #$01
XLDA13:  sta     DISK_ERR
         lda     IWM_MOTOR_OFF,x
         rts

LDA1A:   lda     #$00
         sta     DISK_SECT
         lda     LD69F+2
         sta     $df67
         lda     LD6D0+2
         sta     $df68
         lda     LD506+1
         sta     $df69
         lda     LD506+2
         sta     $df6a
         lda     #$d9
         sta     LD506+2
         lda     #$06
         sta     LD506+1
         lda     DISK_TRK_ADDR
         sta     LD69F+2
         sta     LD6D0+2
XLDA4A:  lda     #$02
         sta     SCRNHOLE5
         lda     #$04
         sta     SCRNHOLE1
         lda     DISK_OP
         jsr     LD4A8
         bcs     XLDA75
         lda     IWM_MOTOR_ON,x
         inc     LD69F+2
         inc     LD6D0+2
         inc     DISK_SECT
         inc     DISK_TRK_ADDR
         lda     #$10
         cmp     DISK_SECT
         bne     XLDA4A
         lda     IWM_MOTOR_OFF,x
XLDA75:  lda     $df67
         sta     LD69F+2
         lda     $df68
         sta     LD6D0+2
         lda     $df69
         sta     LD506+1
         lda     $df6a
         sta     LD506+2
         rts

LDA8E:   DB   $01
         DB   $30
         DB   $28
         DB   $24
         DB   $20
         DB   $1e
         DB   $1d
         DB   $1c
         DB   $1c
         DB   $1c
         DB   $1c
         DB   $1c
SLOT_TO_Y:
         lda     DISKSLOTCX ;Get slot number *16
         lsr     A          ;Divide by 16
         lsr     A
         lsr     A
         lsr     A
         tay                ;Put Acc into Y
         rts

; What sort of not Disk ][ is it?
IDC_CHECK:
         cmp     #$07       ;What sort of drive?
         beq     SMARTDRV_FOUND
         jmp     PRODOS

;*******************************************************************************
;* SmartDrive code                                                             *
;*******************************************************************************
SMARTDRV_FOUND:
         txa                ;Convert to CX
         ora     #$c0
         sta     SMARTDRV_CALL+2 ;Save slot rom into call high
         sta     GET_SMARTDRV_ADDR+2 ;Save slot rom to get entry point
GET_SMARTDRV_ADDR:
         lda     $c7ff      ;Get the entry point
         clc
         adc     #$03       ;Add 3 to get smartdrive point
         sta     SMARTDRV_CALL+1 ;Update the call low byte
         lda     DISK_OP
         beq     SET_DISK_ERR1 ;Status returns error $01
         cmp     #$03       ;Read or write
         bcc     SMART_CMDOK ;Yep carry on
SET_DISK_ERR1:
         ldx     #$01       ;Set disk error to 1 (bad cmd)
         bne     SET_DISK_ERRX

SMART_CMDOK:
         adc     #$07       ;Change from Block to byte command
         sta     SMARTDRV_CMD
; For the smart drive address to read is
; (TRACKH*$100+TRACKL) * $10 + SECT*2
         asl     DISK_SECT  ;8 sectors per track
         lda     DISK_TRKL
         ldy     #$04       ;Shift left 4 times (aka mult by 16)
SMART_MUL:
         asl     A
         rol     DISK_TRKH
         dey
         bne     SMART_MUL
         ora     DISK_SECT  ;Or in the sector
         sta     SMARTDRV_BLOCKNUM+1
         lda     DISK_TRKH
         sta     SMARTDRV_BLOCKNUM+2
SMARTDRV_CALL:
         jsr     $0000
SMARTDRV_CMD:
         DB   $08
         DW   SMARTDRV_PARAM

PD_CHECK_ERR:
         ldx     #$00       ;Everything happy
         bcc     SET_DISK_ERRX ;Yeah store success and return
         inx                ;Nope setup for a error
         cmp     #$2b       ;Write protected error?
         bne     SET_DISK_ERRX ;Lets say it's generic error
         ldx     #$10       ;Write protect error
SET_DISK_ERRX:
         stx     DISK_ERR
         rts

;*******************************************************************************
;* Prodos driver code                                                          *
;*******************************************************************************
PRODOS:  txa
         ora     #$c0
         sta     PD_CALL_DRIVER+2 ;Patch up the driver call
         sta     PD_GET_ENTRY+2 ;Patch the call to find the driver entry
PD_GET_ENTRY:
         lda     $c7ff      ;Get the entry point
         sta     PD_CALL_DRIVER+1 ;Patch the call
         lda     DISK_DRV
         sta     PRODOS_UNITNUM
         lda     DISK_OP    ;Status commmand? Return eror
         beq     SET_DISK_ERR1
         cmp     #$04       ;Greater than 3 not simple.
         bcs     PD_MULT_SECT_OP
         pha
         jsr     TRKSEC2PD_BLK ;Convert track / sector to ProDosBloc
         pla
PD_ALT_CALL:
         sta     PRODOS_CMD ;Copy the command over
         lda     #$00
         sta     PRDOOS_BUFPTRL ;Buffer is at $800
         lda     #$08
         sta     PRDOOS_BUFPTRL+1
PD_CALL_DRIVER:
         jsr     $0000
         jsr     PD_CHECK_ERR
         bcs     PD_EXIT    ;Did we have an error?
         lda     PRODOS_CMD
         cmp     #$03       ;Was it initialise?
         beq     PD_INIT_DATA ;Do the rest of the track
PD_EXIT: rts

PD_INIT_DATA:
         lda     #$18       ;Looks like this skips the first three tracks
         sta     DISK_SECT
PD_INIT_WR:
         lda     #$00       ;Zero the high block
         sta     PRODOS_BLKNUM+1
         lda     DISK_SECT  ;Which block to write
         sta     PRODOS_BLKNUM
         lda     #$02       ;Setup for a write
         jsr     PD_ALT_CALL ;Write out sector
         bcs     PD_EXIT    ;Error go home
         inc     DISK_SECT  ;Next sector
         dec     DISK_TRKL  ;Until the counter =0
         bne     PD_INIT_WR
         rts

;*******************************************************************************
;* We get here if the command is greater than or equal to four.                *
;* Normal ProDOS commands are                                                  *
;* 0 - Status                                                                  *
;* 1 - Read                                                                    *
;* 2 - Write                                                                   *
;* 3 - Init                                                                    *
;* Extended commands (read / write a whole track?)                             *
;* 4 - gets translated as (4-3)^3 so to a 2 - Write                            *
;* 5 - gets translated as (5-3)^3 so to a 1 - Read                             *
;* 6 - gets translated as (6-3)^3 so to a 0 - status                           *
;*******************************************************************************
PD_MULT_SECT_OP:
         sec                ;Do the conversion
         sbc     #$03
         eor     #$03
         sta     PRODOS_CMD ;Set the command
         lda     #$08       ;Whole track?
         sta     PD_TRACK_OP_CNT
         lda     DISK_TRK_ADDR ;Get disk data pointer
         sta     PRODOS_BUFPTRH
         lda     #$00
         sta     DISK_SECT  ;We're doing the whole track
         sta     PRDOOS_BUFPTRL
         jsr     TRKSEC2PD_BLK ;Convert to PD block
PD_TRACK_OP_LOOP:
         jsr     PD_CALL_DRIVER
         bcs     PD_EXIT    ;Flag we had an error
         inc     DISK_TRK_ADDR ;Add 512 bytes to destination / source
         inc     DISK_TRK_ADDR
         inc     PRODOS_BLKNUM ;Bounce the block number along
         bne     PD_BLK_NO_WRAP
         inc     PRODOS_BLKNUM+1
PD_BLK_NO_WRAP:
         inc     PRODOS_BUFPTRH ;Do the ProDOS address
         inc     PRODOS_BUFPTRH
         dec     PD_TRACK_OP_CNT ;Do the loop
         bne     PD_TRACK_OP_LOOP
         rts

TRKSEC2PD_BLK:
         lda     DISK_TRKH  ;Prodos block is TRACK*8 + SECT
         sta     PRODOS_BLKNUM+1
         lda     DISK_TRKL
         ldx     #$03
BLK_MULT_2:
         asl     A          ;Multiply by two
         rol     $47
         dex
         bne     BLK_MULT_2
         ora     DISK_SECT  ;Add sector
         sta     PRODOS_BLKNUM
         rts

SMARTDRV_PARAM:
         DB   $04
SMARTDRV_UNITNUM:
         DB   $01
SMARTDRV_BUFPTR:
         DW   $0800
SMARTDRV_NUMBYTES:
         DW   $0200
SMARTDRV_BLOCKNUM:
         DB   $00
         DB   $00
         DB   $00
PD_TRACK_OP_CNT:
         DB   $00
         ds    83,$00

;*******************************************************************************
;* Various routines                                                            *
;* These get copied out of $DC00 into $0A00                                    *
;* They also get copied into the other bank of memory                          *
;* So probably have some banking code in there.                                *
;*******************************************************************************
         .PHASE 0A00H
         cld
         pha
         txa
         bne     XL0A0E
         bit     LCBANK1
         bit     LCBANK1
         jmp     PRINT_STACK_CHAR

XL0A0E:  bpl     XL0A19
         bit     LCBANK1
         bit     LCBANK1
         jmp     LD000

XL0A19:  stx     ROMSLOT+1
         lda     SLOT_INFO,x
         and     #$0f
         pha
         txa
         asl     A
         asl     A
         asl     A
         asl     A
         tax
         pla
         cmp     #$03       ;Possibly serial card
         beq     CARD3
         cmp     #$04       ;High speed serial
         beq     CARD4
         cmp     #$05       ;Parallel printer
         beq     CARD5
         cmp     #$06       ;Pascal based card
         beq     CARD6
         pla
         bne     L0AA2
CARD6:   pla
         cpy     #$0e
         beq     XL0A54
         cpy     #$0f
         beq     XL0A54
         cpy     #$0d
         beq     XL0A54
         cpy     #$10
         bne     L0AA2
         jsr     XL0A54
         bcs     CARDRETFF
         bcc     L0AA2

XL0A54:  sty     XL0A61+1
         pha
         jsr     L0B06
         stx     XL0A61+2
         stx     XL0A68+2
XL0A61:  lda     $c100
         sta     XL0A68+1
         pla
XL0A68:  jmp     $c100

CARD5:   pla
         cpy     #$0d
         beq     CARDRETFF
         cpy     #$10
         beq     XL0A83
         cpy     #$0f
         bne     L0AA2
         pha
XL0A79:  jsr     XL0A83
         beq     XL0A79
         pla
         sta     IWM_PH0_OFF,y
         rts

XL0A83:  jsr     L0B06
         stx     XL0A89+2
XL0A89:  lda     $c0c1
         bmi     L0AA2
CARDRETFF:
         lda     #$ff
         rts

CARD4:   pla
         cpy     #$10
         beq     CARDRETFF
         cpy     #$0d
         beq     L0B00
         cpy     #$0f
         beq     L0AF5
         cpy     #$0e
         beq     L0AEB
L0AA2:   lda     #$00
         rts

CARD3:   pla
         cpy     #$10
         beq     XL0AD2
         cpy     #$0f
         beq     XL0AC3
         cpy     #$0d
         beq     XL0ADF
         cpy     #$0e
         bne     L0AA2
XL0AB6:  lda     #$01
         jsr     XL0AD2
         beq     XL0AB6
         lda     IWM_Q7_ON,x
         lda     #$ff
         rts

XL0AC3:  pha
XL0AC4:  lda     #$00
         jsr     XL0AD2
         beq     XL0AC4
         pla
         sta     IWM_Q7_ON,x
         lda     #$ff
         rts

XL0AD2:  tay
         lda     IWM_Q7_OFF,x
         lsr     A
         dey
         beq     XL0ADB
         lsr     A
XL0ADB:  bcc     L0AA2
         bcs     CARDRETFF

XL0ADF:  lda     #$03
         sta     IWM_Q7_OFF,x
         lda     #$15
         sta     IWM_Q7_OFF,x
         bne     CARDRETFF

L0AEB:   jsr     L0B06
         jsr     $c84d
         lda     $05b8,x
         rts

L0AF5:   pha
         jsr     L0B06
         pla
         sta     $05b8,x
         jmp     $c9aa

L0B00:   jsr     L0B06
         jmp     $c800

L0B06:   stx     SCRNHOLE5
         txa
         tay
ROMSLOT: lda     #$00
         ora     #$c0
         tax
         stx     READROMSLOT+2
         bit     CLRROM
READROMSLOT:
         lda     $c100
         rts
         .DEPHASE
         DS 080H,01AH
        END
