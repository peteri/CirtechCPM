            TITLE 'Runtime BIOS for Cirtech CP/M'
;==========================================================
; Runtime BIOS for Cirtech CPM system.
;
; Created via decompiling by Peter Ibbotson Nov 2023
; Binary code (C) Copyright Cirtech 1985
; Disassembly (C) Copyright Peter Ibbotson
; 
;==========================================================

; Macro to put hi bit ascii strings in the code.
HIBYTE  MACRO MSG
            IRPC X,<MSG>
                IF '&X' NE '"'
                    DB '&X'+080h
                ENDIF
            ENDM
        ENDM
;
; Apple //e hardware addresses as seen from the Z80
;
KBD         EQU 0E000H
KBDSTRB     EQU 0E010H
RDMAINRAM   EQU 0E002H
RDCARDRAM   EQU 0E003H
WRMAINRAM   EQU 0E004H
WRCARDRAM   EQU 0E005H
TXTPAGE1    EQU 0E054H      ;RW display page 1
TXTPAGE2    EQU 0E055H      ;RW display page 2 (or read/write aux mem)
;
; Misc constants
;
ESC         EQU 1BH
CR          EQU 0DH 
LF          EQU 0AH
DSKOP_RD    EQU 01H
DSKOP_WR    EQU 02H
CHAR_OP_INI EQU 0DH             ; Character IO Init (same as pascal offset)
CHAR_OP_RD  EQU 0EH             ; Character IO Read (same as pascal offset)
CHAR_OP_WR  EQU 0FH             ; Character IO Write (same as pascal offset)
CHAR_OP_ST  EQU 10H             ; Character IO Status (same as pascal offset)
;
;6502 Zero page stuff seen from Z80
;
Z80OFFS     EQU 0F000H
ZSLOTX      EQU 0F004H          ; Boot slot 1..7
ZESC_STATE  EQU 0F022H          ; Escape lead in state
ZACC_6502   EQU 0F045H          ; 6502 Acc
ZX_6502     EQU 0F046H          ; 6502 X reg
ZY_6502     EQU 0F047H          ; 6502 Y reg
ZFLAG_6502  EQU 0F048H          ; 6502 flag
;
;6502 stuff in 0300 range as seen from Z80
;
PAGE300Z80  EQU 0F300H          ; Page 300
ROUT_6502   EQU 0F3D0H          ; 6502 routine to call
CARD_Z80    EQU 0F3DEH          ; Card address from Z80 0E401H
DISK_TRKL   EQU 0F380H          ; Disk track low
DISK_SECT   EQU 0F381H          ; Disk sector
DISK_DRV    EQU 0F384H          ; Disk drive slot (060)
DISK_ACTD   EQU 0F385H          ; Disk active drive
DISK_TRKH   EQU 0F386H          ; Disk track high
DISK_OP     EQU 0F388H          ; Disk operation
DISK_ERR    EQU 0F389H          ; Disk Result
DISK_ROUT   EQU 03DCH           ; Disk routine to call
SLOT_INFO   EQU 0F3B8H          ; Slot info
; Constants for TOOLKEY popbuf
LEFTEDGE    EQU 9               ; Left edge of window  
SCRL8       EQU 0428H + LEFTEDGE + Z80OFFS 
SCRL9       EQU 04A8H + LEFTEDGE + Z80OFFS
SCRL10      EQU 0528H + LEFTEDGE + Z80OFFS
SCRL11      EQU 05A8H + LEFTEDGE + Z80OFFS
SCRL12      EQU 0628H + LEFTEDGE + Z80OFFS
DISK_BUFF   EQU 0F800H          ; Disk buffer for BIOS
;
; Shared stuff between ldr bios and here
;
WBOOTJP     EQU  00000H
BDOSJP      EQU  00005H
CCP         EQU  00100H         ; CCP entry
WARMCOPYLEN EQU  05CFFH         ; Warm copy length
DPHTAB      EQU  5E00H          ; Table of DPH for drives
DRVMAP      EQU  5E20H          ; Map of CPM drives to apple drives
;
; Messages for the toolkey popup (see src\boot\toolkey.mac)
;
MSG_TOOLKEY EQU  0FC00H         ; Message box for toolkey
ERR_WRPRO   EQU  0FD90H         ; Write protected error
MSG_DUPLIC  EQU  0FE28H         ; Duplicating disk
;******************************************************************
;*                                                                *
;*  Set the common memory segment, code from here on in lives     *
;*  in the language card shared with both the users code and      *
;*  the BDOS                                                      *
;*                                                                *
;******************************************************************  
            ASEG               ; CSeg stuff lives in common memory
            .Z80
            ORG 0DE00H
            ; Externs from SCB.MAC
            EXTRN @COVEC        ; Console out vectors
            EXTRN @CIVEC        ; Console in vectors
            EXTRN @AOVEC        ; Aux out vectors
            EXTRN @AIVEC        ; Aux in vectors
            EXTRN @LOVEC        ; List out vectors
            EXTRN @MLTIO        ; Multi IO flag          
            EXTRN @MXTPA        ; Top of TPA
            ;
            ; BIOS Jump table, address in Axxx range are in main memory
            ; Not generally accessable from users side
            ;
            jp   B_COLD         ; $A623 0  - Cold Start
WARMJP:     jp   B_WBOOT        ; $DEF8 1  - WBOOT - Warm Start
            jp   B_CONIST       ; $DF35 2  - CONST - Console input character read
            jp   B_CONIN        ; $DF42 3  - CONIN - Read console in
            jp   B_CONOUT       ; $DF04 4  - CONOUT - Write console
            jp   B_LIST         ; $DF0E 5  - LIST - Write to list
            jp   B_AUXOUT       ; $DF09 6  - AUXOUT
            jp   B_AUXIN        ; $DF47 7  - AUXIN
            jp   B_HOME         ; $A84C 8  - HOME
            jp   B_SELDSK       ; $A81B 9  - SELDSK
            jp   B_SETTRK       ; $A84E 10 - SETTRK
            jp   B_SETSEC       ; $A86F 11 - SETSEC 
            jp   B_SETDMA       ; $A874 12 - SETDMA
            jp   B_READ         ; $A53A 13 - READ
            jp   B_WRITE        ; $A564 14 - WRITE
            jp   B_LISTST       ; $DF20 15 - LISTST - List Status
            jp   B_SECTRAN      ; $A818 16 - SECTRAN
            jp   B_CONOST       ; $DF16 17 - CONOST - Output status of console
            jp   B_AUXIST       ; $DF3A 18 - AUXIST - Input status of Aux port
            jp   B_AUXOST       ; $DF1B 19 - AUXOST - Output status of Aux port
            jp   B_DEVTBL       ; $DFA4 20 - DEVTBL - Address of char IO Table
            jp   B_DEVINI       ; $DF4F 21 - DEVINI
            jp   B_DRVTBL       ; $A801 22 - DRVTBL - Drive table
            jp   B_MULTIO       ; $A879 23 - MULTIO 
            jp   B_FLUSH        ; $A812 24 - FLUSH
            jp   B_MOVE         ; $DF54 25 - MOVE
            DB   0C9H,0C9H,0C9H ; ret   26 - TIME
            jp   B_SELMEM       ; $DF7A 27 - SELMEM
            jp   B_SETBNK       ; $A814 28 - SETBNK
            jp   B_XMOVE        ; $A805 29 - XMOVE
            jp   B_USERF        ; $DFA8 30 - USERF
            jp   0000H          ;       31 - RESERV1
            jp   0000H          ;       32 - RESERV2
;
; BIOS data that lives in shared memory
;
            DB 07               ; DE63
CURBANK:    DB 0                ; DE64
DMABANK:    DB 0                ; DE65
DMAADDR:    DW 0                ; DE66
SAVEDE:     DW 0                ; DE68
LDE6A:      DW 0,0,0,0,0,0,0,0
            DW 0,0,0,0,0,0,0,0
            ; Not certain what this is yet
            DS 36               ; DE88
DEVTBL:                         ; DEAE
            DB 'CONSOL',03,00
            DB 'NODEV1',00,00
            DB 'NODEV2',00,00
            DB 'EXTMEM',00,00
            DB 'NODEV4',00,00
            DB 'NODEV5',00,00
            DB 'NODEV6',00,00
            DB 'NODEV7',00,00
            DB 00               ; End of device table
;==================================================================
;
; Reset the world, called from 6502 code at $300
;
;==================================================================
RESETVECT:  ld   (RDMAINRAM),a  ; Setup RAM
            ld   (WRMAINRAM),a  ; Go reset SCB IO vectors and 
            jp   FINDIODEVS     ; do last half of cold boot
;==================================================================
; BIOS Func 1 - WBOOT
; Warm boot CPM, copies CCP into memory and resets vectors.
; Entry
; Nothing
;==================================================================
B_WBOOT:    ld   (RDMAINRAM),a  ; Read from BIOS / BDOS memory
            jp   WBOOT
WBOOT_EXIT: ld   (RDCARDRAM),a  ; Read from aux ram
            jp   CCP          ; Exit to CCP
;==================================================================
; BIOS Func 4 - CONOUT
; Write character to console.   (Screen usually)
; Entry
; C = Character to write
;==================================================================
B_CONOUT:   ld   hl,(@COVEC)    ; Get console out vector
            jr   JPOUT          ; Off to output routine
;==================================================================
; BIOS Func 5 - AUXOUT
; Write character in to aux output. (Serial port usually)
; Entry
; C = Character to write
;==================================================================
B_AUXOUT:   ld   hl,(@AOVEC)    ; Get aux out vector
            jr   JPOUT
;==================================================================
; BIOS Func 6 - LIST
; Write character in to list output. (Printer usually)
; Entry
; C = Character to write
;==================================================================
B_LIST:     ld   hl,(@LOVEC)
JPOUT:      ld   de,VECOUT        ;A8F1
            jr   JPIOFUNC
;==================================================================
; BIOS Func 17 - CONOST
; Get console output status (Screen usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_CONOST:   ld   hl,(@COVEC)
            jr   JPOST
;==================================================================
; BIOS Func 19 - AUXOST
; Get auxiliary output status (Serial port usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_AUXOST:   ld   hl,(@AOVEC)
            jr   JPOST
;==================================================================
; BIOS Func 15 - LISTST
; Get list status (Printer usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_LISTST:   ld   hl,(@LOVEC)
JPOST:      ld   de,VECOST         ;Output status A910
JPIOFUNC:   ld   (RDMAINRAM),a
            jp   IOFUNC
; IO Bios routines come back to here
; Assumption is memory is in main
IOEXIT:     ld   b,a            ; save acc
            ld   a,(CURBANK)    ; Get current bank
            or   a              ; Set flags
            ld   a,b            ; restore acc
            ret  z              ; Go home if it's main bank
            jr   B_MEMCARD      ; Set to Aux card memory
;==================================================================
; BIOS Func 2 - CONIST
; Get console input status (Keyboard usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_CONIST:   ld   hl,(@CIVEC)
            jr   JPIST
;==================================================================
; BIOS Func 18 - AUXIST
; Get auxiliary input status (Serial port usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_AUXIST:   ld   hl,(@AIVEC)
JPIST:      ld   de,VECIST      ;A969
            jr   JPIOFUNC
;==================================================================
; BIOS Func 3 - CONIN
; Get console input, wait for character.
; Entry
; Exit
; A=Character from keyboard
;==================================================================
B_CONIN:    ld   hl,(@CIVEC)
            jr   JPIN
;==================================================================
; BIOS Func 7 - AUXIN
; Get character from auxiliary input (Serial port usually)
; Entry
; Exit
; A=Character from aux input
;==================================================================
B_AUXIN:    ld   hl,(@AIVEC)
JPIN:       ld   de,VECIN      ;A980
            jr   JPIOFUNC
;==================================================================
; BIOS Func 21 - DEVINI
; Initialise device in c register. Called after baud rate changes
; Entry
; C = device number in DEVTBL
; Exit
;==================================================================
B_DEVINI:   ld   de,DEVINI     ;AF12
            jr   JPIOFUNC
;==================================================================
; BIOS Func 25 - MOVE
; Copy memory (sadly wrong order for Z80)
; Also copies across banks if XMOVE has been called.
; Entry
; BC = Number of bytes to move
; DE = Source address
; HL = Dest addresss
; Exit
;==================================================================
B_MOVE:     ld   a,00H          ; 0 if there is XMOVE settings 
            or   a              ; If last call wasn't XMOVE
            jr   nz,MOVEMEM     ; just do the regular mem move
            inc  a              ; if it's xmove this time assume normal 
            ld   (B_MOVE+1),a    ; move next time we get called.
XMOVE_CREG: ld   a,00H          ; XMOVE sets this value to read bank
            ld   (RDMAINRAM),a  ; Assume main memory BIOS/BDOS
            or   a              ; for read bank
            jr   z,XMOVE_BREG   ; Not zero so reading from 
            ld   (RDCARDRAM),a  ; Aux card ram
XMOVE_BREG: ld   a,00H          ; XMOVE sets this value for write bank
            ld   (WRMAINRAM),a  ; Assume main memory BIOS/BDOS 
            or   a              ; for write bank
            jr   z,MOVEMEM      ; Not zero so writing to aux ram
            ld   (WRCARDRAM),a  
MOVEMEM:    ex   de,hl          ; Swap de,hl for CP/M MOVE
            ldir                ; Do the copy
            ex   de,hl          ; swap back and fall thru, to sort out bank.
            ld   a,(CURBANK)    ; Restore back to correct bank
;==================================================================
; BIOS Func 27 - SELMEM
; Set the current memory bank to bank in A register
; Entry
; A=Bank to select
; Exit
;==================================================================
B_SELMEM:   ld   (CURBANK),a    ; Save away the bank requested
B_SELMEM2:  or   a              ; set flag for jumps
            jr   nz,B_MEMCARD   ; Not zero use aux card for the user stuff
            ld   (RDMAINRAM),a  ; Nope we're in BIOS / BDOS land
            ld   (WRMAINRAM),a
            ret
B_MEMCARD:  ld   (RDCARDRAM),a  ; Time for the Users code
            ld   (WRCARDRAM),a
            ret
;==================================================================
; Copy DMA buffer to disk buffer, if zero flag 
; set then copy from main memory bank, otherwise
; it's the auxiliary bank.
;==================================================================
DMA2BUF:    jr   z,DMANOTAUX    ; DMA is from aux bank
            ld   (RDCARDRAM),a  ; set it up.
DMANOTAUX:  ld   de,DISK_BUFF   ; Dest is disk buffer
            ld   hl,(DMAADDR)   ; Source is DMA address
            jr   DMANOTAUX
CPFROMCARD: ld   (RDCARDRAM),a  ; DF9B -
DMADOCOPY:  ldir                ; Do the copy
            ld   (RDMAINRAM),a  ; back to main memory
            ret                 ; Helps with return addresses
;==================================================================
; BIOS Func 20 - DEVTBL
; Get the device table.
; Entry
; Exit
; HL=Address of the table
;==================================================================
B_DEVTBL:   ld   hl,DEVTBL
            ret
;==================================================================
; BIOS Func 30 - USERF
; User functions
; Entry
; Exit
;==================================================================
B_USERF:    ld   (SAVEDE),de
            ld   de,USERF
            jp   JPIOFUNC
;******************************************************************
;*                                                                *
;*  Time to swap segments, code from here on in lives in the      *
;*  shared memory with the BDOS                                   *
;*                                                                *
;******************************************************************            
            ASEG
            ORG 0A400H
SIGNONMSG:  DB ESC,'*',CR,LF
            DB '         ',ESC,'(','  CP/M Plus Version 3.0  for the Apple //e  ',CR,LF,ESC,')'
            DB '         ',ESC,'(','    (C)  CIRTECH 1985       Release 1.07    ',CR,LF,ESC,')'
            DB CR,LF,0
ODDCODE:    DS 20H                  ;A47D - Could be a table here!            
;
;
;
BIOSTK:     DS 058H      ;No idea if right size
BIOSTOS:
;==================================================================
; All of the character device IO routines end up here
; as do the user function calls. Swaps stack to BIOS one
; Entry 
; DE = Routine to call
; HL = Vector for devices for character IO
;==================================================================
IOFUNC:     ld   (WRMAINRAM),a      ; Write to main memory
            ld   (IORESSTK+1),sp    ; Save stack pointer for restore
            ld   sp,BIOSTOS         ; End of BIOSSTK
            push af                 ; Save acc
            xor  a                  ; Ask for main card memory
            call B_SELMEM2          ; Get the memory
            pop  af                 ; Restore accumulator
            ld   (IOCALL+1),de      ; Setup for the call
IOCALL:     call 0000H              ; call de
IORESSTK:   ld   sp,0000H           ; Bring back the stack
            jp   IOEXIT             ; Exit back
;==================================================================
; WBOOT - Warm boot
;   Copy memory from main memory at 0100H into
;   main memory, reset flags and vectors and run CCP
; Entry
; Nothing
; Exit
; Runs CCP
;==================================================================
WBOOT:      ld   (WRCARDRAM),a      ; Write to aux ram
            ld   hl,CCP             ; Copy CCP into aux ram
            ld   d,h
            ld   e,l
            ld   bc,WARMCOPYLEN     ; Get copy length
            ldir                    ; Do the copy
            xor  a                  ; Reset multi io flag?
            ld   (@MLTIO),a         
            ld   hl,(@MXTPA)        ;Top of TPA (aka BDOS)
            ld   (BDOSJP+1),hl      ;set BDOS jump
            ld   a,0C3H             ; JP OpCode
            ld   (WBOOTJP),a        ; Set up jump at 0000
            ld   (BDOSJP),a         ; Set up jump at 0005
            ld   hl,WARMJP          ; Entry in jump Table
            ld   (WBOOTJP+1),hl     ; Store that
            jp   WBOOT_EXIT         ; Jump back out into CCP
;==================================================================
; BIOS Func 13 - READ
; Read in a sector into the DMA address.
; Entry
; Exit
; A = 0 for OK
;     1 for Unrecoverable error
;     FF if media changed.
;==================================================================
B_READ:     ld   (DISKEXIT+1),sp    ; Save stack pointer
            ld   sp,BIOSTOS         ; Set to local stack
            ld   a,DSKOP_RD         ; read operation
            call DISKOPER           ; Do it
            push af
            call GETSECTSZ          ; Get the sector size
            ld   a,(DMABANK)        ; Get the DMA bank
            or   a
            jr   z,READTOMAIN       ; We're in the right one?
            ld   (WRCARDRAM),a      ; Copy into aux card instead
READTOMAIN: ld   de,(DMAADDR)       ; Start the copy into
            ld   hl,DISK_BUFF       ; DMA address from DISK_BUFF
            ldir
            ld   (WRMAINRAM),a      ; Set us back to main ram
            pop  af                 ; Get back error code
DISKEXIT:   ld   sp,0000H           ; Restore stack and home
            ret
;==================================================================
; BIOS Func 14 - WRITE
; Write out a sector.
; Entry
; C = 0 - Write can be deferred (only in BIOS deblocking)
;     1 - Write must be immediate
;     2 - Write can be deferred, no pre-read is necessary.
; Exit
; A = 0 for OK
;     1 for Unrecoverable error
;     2 - Read only error
;     FF if media changed.
;==================================================================
B_WRITE:    ld   (DISKEXIT+1),sp    ; Save stack pointer
            ld   sp,BIOSTOS         ; Stack to BIOS one
            call GETSECTSZ          ; How big are our sectors
            ld   a,(DMABANK)        ; Get the bank
            or   a                  ; Set zero flag
            call DMA2BUF            ; Copy DMA to DISK buffer
            ld   a,DSKOP_WR         ; write operation
            call DISKOPER           ; do disk operation
            jr   DISKEXIT
;=================================================
; Gets the sector size for the current drive
; returns sector size in bc
;=================================================
GETSECTSZ:  ld   bc,0100H           ; Assume it's a Disk ][
            ld   a,(DISK_DRV)       ; Get the drive
            call DRVISDISK2
            ret  z                  ; Go home if it was a Disk II
            ld   bc,0200H           ; Other sector size is 512 bytes
            ret
;=================================================
; Perform a disk operation
;=================================================
DISKOPER:   call 0AA7FH
            ld   (DISK_OP),a    ; Set the disk operation
DISKRETRY:  ld   hl,DISK_ROUT   ; Tell the 6502 code 
            ld   (ROUT_6502),hl ; to call the disk BIOS
            ld   hl,(CARD_Z80)  ; Get the Z80 address
            ld   (hl),a         ; Off to 6502 land
            ld   a,(DISK_ERR)   ; We're back did we get an error
            or   a              ; Set the flag
            ret  z              ; Return back if there wasn't error
            ld   c,07H          ; Ring the bell
            call C_TO_CONS      ; Character in C to console
            di
            call DRWTOOLKY      ; Draw toolkey box
            ld   a,(DISK_ERR)   ; Get the error message
            cp   010H           ; Write only?
            jr   nz,NOTWRPRO    ; Nah fix message for read / write
            ld   hl,ERR_WRPRO   ; Write protected error 
            jr   DISPDSKERR     ; Display error message
NOTWRPRO:   ld   a,(DISK_OP)    ; Read or write operation
            cp   DSKOP_WR
            ld   hl,MSG_WRERR   ; Assume write
            jr   z,OPNOTWR      ; Yes it was
            ld   hl,MSG_RDERR   ; Nope it was read
OPNOTWR:    ld   de,MSG_ERRDST  ; Overwrite message
            ld   bc,5           ; with read or write.
            ldir
DSKERR_DRV: ld   a,00H          ; Drive error letter
            add  a,'A'+80H      ; Put it into 'A'-'Z'
            ld   (MSGERRDRV),a  ; Put the drive letter in message
            ld   hl,MSG_DSKERR  ; Write message into screen
DISPDSKERR: call USERF_07       ; Put message in popup
            call USERF_0B       ; Read lower case character from keyboard
            jr   nz,ER_NOT_ESC  ; User hit escape?
            call USERF_06       ; Yeah, lets abort the world screen
            jp   B_WBOOT        ; back to normal and do a warm boot.
ER_NOT_ESC: cp   'y'            ; User wanted a retry
            push af             ; Save the flag
            call USERF_06       ; Put back the screen
            pop  af             ; Get back the flag to see if user
            jr   z,DISKRETRY    ; wanted us to retry, loop back again.
            ld   a,(DISK_ERR)   ; Get disk error code
            cp   10H            ; Write protect error?
            ret  nz             ; Nope, go home
            ld   a,02           ; Convert to CP/M error
            ret
MSG_DSKERR: HIBYTE "Disk "
MSG_ERRDST: HIBYTE "Write Error on "
MSGERRDRV:  HIBYTE "A: Try again Y/N ?"
MSG_RDERR:  HIBYTE "Read "
MSG_WRERR:  HIBYTE "Write"
;==================================================================
; BIOS Func 0 - Cold boot
; Cold boot routines, sets up the drives, IO vectors
; Copies device tables into place
; and calls the warm boot
; Entry
; Exit
;==================================================================
B_COLD:
A623: 32 10 E0    ld   (KBDSTRB),a
A626: 11 6A DE    ld   de,LDE6A
A629: 21 BC 5D    ld   hl,$5DBC
A62C: 01 44 00    ld   bc,$0044
A62F: ED B0       ldir
A631: 21 2C 5E    ld   hl,$5E2C
A634: 22 BA 6E    ld   ($6EBA),hl
A637: 21 88 6A    ld   hl,$6A88
A63A: 22 BC 6E    ld   ($6EBC),hl
A63D: DD 21 00 5E ld   ix,$5E00
A641: DD 22 02 A8 ld   (B_DRVTBL+1),ix
A645: DD 6E 00    ld   l,(ix+00)
A648: DD 23       inc  ix
A64A: DD 66 00    ld   h,(ix+00)
A64D: 7C          ld   a,h
A64E: B5          or   l
A64F: 28 1E       jr   z,$A66F
A651: DD 23       inc  ix
A653: E5          push hl
A654: FD E1       pop  iy
A656: FD 6E 0C    ld   l,(iy+0CH)
A659: FD 66 0D    ld   h,(iy+0DH)
A65C: 11 BC 5D    ld   de,$5DBC
A65F: B7          or   a
A660: ED 52       sbc  hl,de
A662: EB          ex   de,hl
A663: 21 6A DE    ld   hl,LDE6A
A666: 19          add  hl,de
A667: FD 75 0C    ld   (iy+0CH),l
A66A: FD 74 0D    ld   (iy+0DH),h
A66D: 18 D6       jr   $A645
A66F: 11 BE DD    ld   de,@CIVEC     ;SCB things? @CIVEC?
A672: 21 45 AF    ld   hl,$AF45
A675: 01 0A 00    ld   bc,$000A
A678: ED B0       ldir
;
; Setup DEVTBL to match cards in slots
;
            ld   ix,SLOT_INFO+7 ;Get the slot info
            ld   b,$07          ; Count down
DEVCPYLOOP: ld   a,(ix+$00)     ; Get card type
            dec  ix
            cp   0F0H           ; Hi nybble clear
            jr   c,OLDCARD      ; Yes it's an old card or disk
            and  0F0H           ; Mask off pascal card type
            cp   0A0H           ; Bigger than we know?
            jr   nc,CARD_UNNWN
            rrca                ; Pascal card
            add  a,50H          ; Add offset in table
            jr   CARD_KNOWN
CARD_UNKWN: ld   a,1            ;Set for unknown card
OLDCARD:    rlca                ;Multiply by 8 
            rlca
            rlca
CARD_KNOWN: ld   d,0            ; Get card info
            ld   e,a
            ld   iy,CARD_TYPES  ; into iy
            add  iy,de
            ld   a,b            ; Slot number
            add  a,'0'          ; Convert to ASCII
            ld   (iy+5),a       ; Store it so IODEV becomes IODEVx
            ld   a,b            ; Get slot number
            sla  a              ; multiply by 8
            sla  a
            sla  a
            ld   e,a            ; Set our destination in the dev table
            ld   d,0
            ld   hl,DEVTBL      ; Add the index to devtbl
            add  hl,de
            ex   de,hl          ; Swap DE and HL
            push iy             ; set our source address
            pop  hl
            push bc             ; Save our counter for later
            ld   bc,8           ; Copy over the entry
            ldir
            pop  bc             ; Restore our counter
            djnz DEVCPYLOOP     ; Next card please
;            
; Reset the SCB DEVICE vectors
; First find the LST device
;
FINDIODEVS: ld   sp,BIOSTOS     ; Reset stack (again)
            ld   d,0            ; Slot number
            ld   b,080h         ; walk this bit down
            ld   hl,SLOT_INFO+1 ; Start at slot 1
FNDLSTLOOP: inc  d              ; Next slot number
            srl  b              ; Walk bit mask down
            jr   c,INITDEVS     ; fell of end? check for aux
            ld   a,(hl)         ; Get this slot card type
            ld   e,a            ; Save for later
            and  0FH            ; Not a pascal card check
            inc  hl             ; increment our pointer
            cp   7              ; Disk drive of some sort?
            jr   nc,FNDLSTLOOP  ; Goto get next slot
            cp   3              ; Disk II or unknown?
            jr   c,FNDLSTLOOP   ; Yes go around again
            cp   6              ; Not a pascal card
            jr   nz,FOUNDLST    ; Must be type 3/4 so save it
            ld   a,e            ; Get back card type
            and  0F0H           ; Mask off pascal type
            cp   010H           ; Pascal printer
            jr   z,FOUNDLST     ; Yes please
            cp   030H           ; Serial or parallel IO
            jr   nz,FNDLSTLOOP  ; Nope loop again
FOUNDLST:   ld   a,d            ; Lst slot number
            ld   (LSTSLOT),a    ; Lst slot number
            ld   c,0            ; Zero top half
            ld   (@LOVEC),bc    ; Set List out vector
;
; Now we'll try and find the AUX device
;
FNDAUXLOOP: inc  d              ; Next slot number
            srl  b              ; walk this bit down
            jr   c,INITDEVS     ; fell of end? all done then
            ld   a,(hl)         ; Get card type
            ld   e,a            ; Save card type for later
            and  00FH           ; Mask off card type
            inc  hl             ; bounce pointer
            cp   3              ; Communications card?
            jr   z,FOUNDAUX     ; Yes we're done
            cp   4              ; Serial card?
            jr   z,FOUNDAUX     ; Yes we're done
            cp   6              ; Pascal card?
            jr   nz,FNDAUXLOOP  ; Nope loop around
            ld   a,e            ; Get back card type 
            and  0F0H           ; Mask off pascal type
            cp   030H           ; Pascal Serial or parallel IO
            jr   z,FOUNDAUX     ; Yep we're done
            cp   040H           ; Pascal Modem
            jr   z,FOUNDAUX     ; Yep we're done
            cp   090H           ; 80 column card (not //e?)
            jr   nz,FNDAUXLOOP  ; Nope try next slot
FOUNDAUX:   ld   a,d            ; Aux slot number
            ld   (AUXSLOT),a    ; Aux slot number
            ld   (@AOVEC),bc    ; Aux out vector
            ld   (@AIVEC),bc    ; Aux in vector
; Initialise devices
INITDEVS:   ld   sp,BIOSTOS     ; Reset stack (again)
            ld   c,7            ; We have seven slots
DEVININEXT: push bc             ; Save counter
            call DEVINI         ; Initialise device
            pop  bc             ; Restore counter
            dec  c              ; loop until done
            jr   nz,DEVININEXT
            ld   de,RESETVECT   ; Routine to call when user hits reset
            ld   a,e
            ld   (0F306H),a     ; put the new value into 6502 code
            ld   a,d            ; 6502 code puts this into the 
            ld   (0F30BH),a     ; Z80 reset vector
            xor  a              ; Zero accumulator
            ld   (WRCARDRAM),a
            ld   (ZESC_STATE),a ; Reset Console escape state
            ld   (WRMAINRAM),a
            di                  ; turn off interrupts
            ld   hl,SIGNONMSG
            ld   a,(hl)
SIGNONLOOP: ld   c,a
            push hl
            call C_TO_CONS
            pop  hl
            inc  hl
            ld   a,(hl)
            or   a
            jr   nz,SIGNONLOOP
A75B: CD 26 AF    call $AF26
            jp   B_WBOOT
CARD_TYPES: DB 'NOCRD ',00,00       ; 00 Card type 00
            DB 'UNKWN ',00,00       ; 08 Card type 01
            DB 'DSKII ',00,00       ; 10 Card type 02
            DB 'COMCD ',0B,00       ; 18 Card type 03
            DB 'SERCD ',0B,00       ; 20 Card type 04
            DB 'PRINT ',02,00       ; 28 Card type 05
            DB '      ',00,00       ; 30 Card type 06 - pascal
            DB 'RAMDR ',00,00       ; 38 Card type 07
            DB 'PDISK ',00,00       ; 40 Card type 08
            DB 'FDISK ',00,00       ; 48 Card type 09
            DB 'UNKWN ',00,00       ; 50 Card type 06 - Pascal, Unknown
            DB 'PRTCD ',02,00       ; 58 Card type 16 - Pascal, Printer 
            DB 'MOUSE ',01,00       ; 60 Card type 26 - Pascal, X / Y Device
            DB 'IODEV ',0B,00       ; 68 Card type 36 - Pascal, Serial or parallel IO
            DB 'MODEM ',0B,00       ; 70 Card type 46 - Pascal, Modem
            DB 'SOUND ',03,00       ; 78 Card type 56 - Pascal, Sound or speech
            DB 'CLOCK ',02,00       ; 80 Card type 66 - Pascal, Clock
            DB 'STORE ',03,00       ; 88 Card type 76 - Pascal, Mass storage
            DB '80COL ',02,00       ; 90 Card type 86 - Pascal, 80 column
            DB 'ATALK ',0B,00       ; 98 Card type 96 - Pascal, Network or bus interface
;==================================================================
; BIOS Func 22 - B_DRVTBL 
; Get the drive table, returns the address of the drive table.
; Entry
; Exit 
; HL = DRVTBL
;==================================================================
B_DRVTBL:   ld   hl,LDE6A           ; Cold boot sets this to 5E00
            ret   
;==================================================================
; BIOS Func 29 - B_XMOVE 
; Move memory acrooss banks
; Entry 
; C=source bank
; B=destination bank
; Exit   
;==================================================================
B_XMOVE:    ld   a,c
            ld   (XMOVE_CREG+1),a   ; Save source bank
            ld   a,b
            ld   (XMOVE_BREG+1),a   ; Save destination bank
            xor  a
            ld   (B_MOVE+1),a       ; Flag move as XMOVE
            ret
;==================================================================
; BIOS Func 24 - B_FLUSH 
; Write any pending data to disk
; Only useful if BIOS is doing deblocking
; Entry
; Exit
; A = 0
;==================================================================
B_FLUSH:    xor  a
            ret
;==================================================================
; BIOS Func 28 - B_SETBNK
; Set the bank to use for DMA operations
; Entry
; A = bank to use for DMA
; Exit 
;==================================================================
B_SETBNK:   ld   (DMABANK),a
            ret
;==================================================================
; BIOS Func 16  - SECTRAN
; Translate sector
; Entry
; BC = Logical sector number
; DE = Address of translation table
; Exit
; HL = Physical sector number
;==================================================================
B_SECTRAN:  ld   h,b
            ld   l,c
            ret
;==================================================================
; BIOS Func 9 - SELDSK
; Select the disc drive in register C
; Entry
; C = Drive 0=A, 1=B....
; E = 0 or FFFFH, if Bit 0 is 1 disc has been logged before
;                 if Bit 0 is 0 disc is logged as if new
;                 can cause a disc read to figure out DPH from
;                 boot sector.
; Exit
; HL = Disk parameter Header
;==================================================================
B_SELDSK:   ld   a,c
            ld   (DSKERR_DRV+1),a  ; Save drive for error message later
            ld   b,0
            ld   hl,DRVMAP
            add  hl,bc
            ld   a,(hl)
            ld   (DISK_DRV),A
            ld   hl,DPHTAB      ; Get DPH for drive
            sla  c              ; Mult by two
            ld   e,c
            ld   d,0
            add  hl,de          ; HL points to DPH for drive
            ld   e,(hl)         ; Get DPH in de
            inc hl
            ld   d,(hl)
            ex   de,hl          ; Put DPH into HL
            ret
;==================================================================
; Drive is disk II 
; Entry
; A = Apple drive code 60=Slot 6 disk 1, E0=slot 6 disk 2
; Exit
; Zero flag set if Disk II drive
;==================================================================
DRVISDISK2: and  07FH           ; Mask off the unit
            rrca                ; Divide by 16
            rrca
            rrca
            rrca
            ld   hl,SLOT_INFO   ; Look up drive type
            ld   e,a 
            ld   d,0
            add  hl,de
            ld   a,(hl)         ; get the drive type
            cp   02H            ; Set zero flag for Disk II drives
            ret
; Unknown at this point
LA848:      adc a,0
            xor b
            ld  h,b
;==================================================================
; BIOS Func 8 - HOME
; Move the current to track 0
; Entry
; Exit
;==================================================================          
B_HOME:     ld  c,0H            ; Set track to zero and fall thru
;==================================================================
; BIOS Func 10 - SETTRK
; Set the track
; Tracks 35,36 and 37 are a bit of a lie on a boot disk
; they're marked as belonging to a file called system.track
; if the disk is a data disk then they're really tracks 0,1,2
; Entry
; BC = Track to set
; Exit
;==================================================================          
B_SETTRK:   ld   (SETTRKEX),sp  ; Save away stack pointer
            ld   sp,BIOSTOS     ; Set bios stack
            ld   a,(DISK_DRV)   ; Get the drive
            call DRVISDISK2     ; See if it's a disk II 
            ld   a,c            ; Set acc to low track bytes
            jr   nz,NOTRKADJ    ; Not disk II so no need to adjust
            cp   35             ; Do we need to wrap track number?
            jr   c,NOTRKADJ     ; Nope so don't adjust
            sub  35             ; Yes we do adjust track
NOTRKADJ:   ld   (DISK_TRKL),a  ; Save away low track
            ld   a,b
            ld   (DISK_TRKH),a  ; And do the high byte
SETTRKEX:   ld   sp,0000H       ; Restore stack pointer
            ret
;==================================================================
; BIOS Func 11 - SETSEC
; Set the sector next disc operation will use
; Size is from the DPH
; Entry
; BC = Sector number
; Exit
;==================================================================            
B_SETSEC:   ld   a,c
            ld   (DISK_SECT),a
            ret
;==================================================================
; BIOS Func 12 - SETDMA
; Set the address next disc operation will use
; Entry
; BC = Address to read or write from
; Exit
;==================================================================
B_SETDMA:   ld   (DMAADDR),bc
            ret
;==================================================================
; BIOS Func 23 - B_MULTIO 
; Multi IO operation setup
; Entry
; Exit
; A = 0
;==================================================================
B_MULTIO:   xor  a
            ret
;==================================================================
; USERF - user function helper
; Entry
; A = routine to call.
; Otherwise BC,DE,HL passed to routine
; Exit
; Unknown
;==================================================================
USERF:      ld   de,(SAVEDE)    ; Pull back de
            ld   (WRMAINRAM),a  ; swap the memory back to main
            cp   10             ; off the end of the table
            ret  nc             ; no, go home
            sla  a              ; double function to get index
            push hl             ; save hl & bc
            push bc
            ld   l,a            ; hl=a*2
            ld   h,0
            ld   bc,USERFTBL    ; Add hl to user table
            add  hl,bc
            ld   c,(hl)         ; get address into bc
            inc  hl
            ld   b,(hl)
            ld   (USERFJP),bc   ; Store into jump
            pop  bc             ; restore bc & hl
            pop  hl
USERFJP:    jp   0000H          ; Off to user function
USERFTBL:   DW   USERF_RET      ; User function 00
            DW   USERF_RET      ; User function 01 
            DW   USERF_RET      ; User function 02
            DW   USERF_RET      ; User function 03
            DW   USERF_04       ; ????? - AB92           
            DW   USERF_05       ; Save the screen - A8BC
            DW   USERF_06       ; Copy drive + Fall through into Screen save - AE75 
            DW   USERF_07       ; Write (hl) to middle of popup on screen - AE5A 
            DW   USERF_08       ; ????? - ABC0 
            DW   USERF_09       ; Copy aux to main memory with range check - A8CB
            DW   USERF_0A       ; Copy main to aux memory with range check - A8DB 
            DW   USERF_0B       ; Get keyboard lower case and compare against ESC -  AE34
            DW   USERF_RET      ; User function 0C 
            DW   USERF_RET      ; User function 0D
            DW   USERF_RET      ; User function 0E
            DW   USERF_RET      ; User function 0F
;==================================================================
; User function 5 saves the screen to 0FF00h then 
; moves lines from de to the screen
;==================================================================
USERF_05:   push de
            ld   de,0FF00H         
            res  7,c
            call SCRMOVE
            pop  de
            set  7,c
            jp   SCRMOVE
;==================================================================
; User function 9 Copies memory from the aux card into main memory
; performs a range check on the src address
;==================================================================
USERF_09:   ld   a,00DH
            cp   d
            ret  nc
            push de
            ex   de,hl
            add  hl,bc
            ld   a,05DH
            cp   h
            ex   de,hl
            pop  de
            call nc,CPFROMCARD  ; Do the copy from lang card code
USERF_RET:  ret
;==================================================================
; User function A Copies memory from the main memory into aux ram
; performs a range check on the src address
;==================================================================
USERF_0A:   push hl
            add  hl,bc
            ld   a,05DH
            cp   h
            pop  hl
            ret  c
            ld   (WRCARDRAM),a
            ldir
            ld   (WRMAINRAM),a
            ret
            .6502
            lda  #$76 	        ; code at $B8EB or 0A8EBH
            sta  USERF          ; Write HALT in USERF 
            rts                 ; but the adress should be +$1000
            .Z80
VECOUT:              ;A8F1
VECOST:              ;A910
LSTSLOT: DB 00 ; A949
AUXSLOT: DB 00 ; A94A
VECIST:              ;A969
VECIN:               ;A980
;==================================================================
; Character in C to console
; Lives at 0A99AH
;==================================================================
C_TO_CONS:  res  7,c            ; Clear the high bit
            ld   b,0            ; Flag we want console
            jr   CON_BIOS
;==================================================================
; Toggle cursor
; Lives at 0A9A0H
;==================================================================            
TOG_CURSOR: ld   b,80H          ; Toggle the cusor
;=================================================================
;        
; Call character IO bios
; Entry
;  a = 6502 Y reg 0DH=Init,0EH=read,0FH=Write,10H=status
;  b = 6502 X reg 0=Console,1..7 slot number,80H=toggle cursor
;  c = 6502 accumulator, character to output.
; Exit
;  a = 6502 accumulator
;     
;=================================================================
CON_BIOS:   ld   hl,0A00H       ; Character device BIOS call
            ld   (ROUT_6502),hl ; put into 6502 region
            ld   (ZY_6502),a    ; Y reg = a
            ld   a,b            ; X reg = b
            ld   (ZX_6502),a
            ld   a,c            ; Acc = c
            ld   (ZACC_6502),a
            ld   hl,(CARD_Z80)  ; Get the card address
            ld   (hl),a         ; Goto 6502 land
            ld   a,(ZACC_6502)  ; Get acc back
            ret
            ;A9BB
LAB73:               ;AB73
USERF_04:            ;AB92
;==================================================================
; Draw the toolkey window
;==================================================================
DRWTOOLKEY: ld   a,(DISK_DRV)   ; Save current disk drive before we 
            ld   (LAB73),a      ; Draw toolkey box
            ld   de,0FF00H      ; Save screen space to 
            res  7,c            ; FF00H
            call SCRMOVE        
            ld   de,MSG_TOOLKEY ; draw the toolkey box on screen
            set  7,C            ; set the flag
            jp   SCRMOVE
;==================================================================
; User function 8 - Some sort of scroll
;==================================================================
USERF_08:            ;ABC0
;==================================================================
; User function B - Get keyboard lower case and compare against ESC
;==================================================================
USERF_0B:   call 0AA7FH
            ld   a,(KBD)
            or   a
            jp   p,USERF_0B
            ld   (KBDSTRB),a
            res  7,a
            or   020H       ; Force lower case
            cp   ESC+020H   ; Was it escape?
            ret
; Lower case drive letter checker
; Entry
;  A = lower case drive letter
; Exit
;  A = Apple II drive slot,drive number code
;  C = CP/M drive 0..25
;  Carry flag set if valid drive
LAE48:      sub  061H           ; Convert a..z to 0..25
            ld   c,a            ; Presumably save for later 
            ld   e,a            ; Put into de
            ld   d,0
            ld   hl,DRVMAP      ; Add it to the drive map address
            add  hl,de
            ld   a,(hl)         ; Look up drive slot info
            or   a              ; Zero
            ret  z              ; Yep go home
            scf                 ; Set carry flag
            ret
LAE57:      ld   hl,MSG_DUPLIC
;==================================================================
; User function 7 - writes 38 characters from (hl) to 
; the middle of the Cirtech toolkey popup
;==================================================================
USERF_07:   ld   b,38
            ld   de,SCRL10+1
UF7_NXTCHR: ld   a,b
            rra
            ld   (TXTPAGE2),a
            jr   c,UF7_ODD
            ld   (TXTPAGE1),a
UF7_ODD:    ld   a,(hl)
            ld   (de),a
            inc  hl
            jr   c,UF7_ODD2
            inc  de
UF7_ODD2:   djnz UF7_NXTCHR
            ld   (TXTPAGE1),a
            ret
;==================================================================
; User function 6 - Restore screen after drawing toolkey
;==================================================================
USERF_06:   ld   a,(LAB73)      ; restore saved disk drive 
            ld   (DISK_DRV),a   ; put it into regular bios
; 
; Screen mover routine, saves or restores screen
; from lines 8-12 columns 18-60 to or from de.
; Direction is controlled by hi bit of C register
; clear is screen to DE, set is DE to screen
;
SCRMOVE:    ld   hl,SCRL8 
            call LINEMOVE
            ld   hl,SCRL9
            call LINEMOVE
            ld   hl,SCRL10
            call LINEMOVE
            ld   hl,SCRL11
            call LINEMOVE
            ld   hl,SCRL12
            call LINEMOVE
            ld   (TXTPAGE1),a
            xor  a
            ret
; Matching line mover
LINEMOVE:   ld   b,42           ; Copy 42 characters
LMV_LOOP:   ld   a,b            ; get our column
            rra                 ; Shuffle it in carry
            ld   (TXTPAGE2),a   ; Use txt page 2
            jr   c,LMV_TSTDIR   ; Even column 
            ld   (TXTPAGE1),a   ; So use page 1
LMV_TSTDIR: bit  7,c            ; Check for direction
            jr   z,LMV_NOSWP    ; Clear so save area to screen
            ex   de,hl          ; swap so screen to save area
LMV_NOSWP:  ld   a,(hl)         ; Get our data
            ld   (de),a         ; Save it
            jr   z,LMV_NOSWP1   ; Swap registers back again
            ex   de,hl
LMV_NOSWP1: inc  de             ; Add one to save area
            jr   c,LMV_ODD      ; Odd column?
            inc  hl             ; Yes don't increment this time
LMV_ODD:    djnz LMV_LOOP
            ret                 ; Go home
;==================================================================
; BIOS Func 21 - DEVINI
; Device initialise
; Entry
; C = Device number to initialise
; Exit
;==================================================================
DEVINI:              ;AF12
            END
