            TITLE 'Runtime BIOS for Cirtech CP/M'
; Runtime BIOS for Cirtech CPM system.
;
; Created via decompiling by Peter Ibbotson Nov 2023
; (C) Copyright Cirtech 1985
;            
RDMAINRAM   EQU 0E002H
RDCARDRAM   EQU 0E003H
WRMAINRAM   EQU 0E004H
WRCARDRAM   EQU 0E005H
ESC EQU 1BH
CR EQU 0DH 
LF EQU 0AH
;
;6502 Zero page stuff seen from Z80
;
ZSLOTX      EQU 0F004H       ; Boot slot 1..7
ZACC_6502   EQU 0F045H       ; 6502 Acc
ZFLAG_6502  EQU 0F048H       ; 6502 flag
;
;6502 stuff in 0300 range as seen from Z80
;
PAGE300Z80  EQU 0F300H          ; Page 300
ROUT_6502   EQU 0F3D0H          ; 6502 routine to call
CARD_Z80    EQU 0F3DEH          ; Card address from Z80 0E401H
DISK_TRKL   EQU 0F380H          ; Disk track low
DISK_SECT   EQU 0F381H          ; Disk sector
DISK_DRV    EQU 0F384H          ; Disk drive slot (060)
DISK_ACTD   EQU 0F385H          ; Disk active drive
DISK_TRKH   EQU 0F386H          ; Disk track high
DISK_OP     EQU 0F388H          ; Disk operation
DISK_ERR    EQU 0F389H          ; Disk Result
DISK_ROUT   EQU 03DCH           ; Disk routine to call
SLOT_INFO   EQU 0F3B8H          ; Slot info
DISK_BUFF   EQU 0F800H          ; Disk buffer for BIOS
;
; Shared stuff between ldr bios and here
;
WBOOTJP     EQU  00000H
BDOSJP      EQU  00005H
CCP         EQU  00100H         ; CCP entry
WARMCOPYLEN EQU  05CFFH         ; Warm copy length
DPHTAB      EQU  5E00H          ; Table of DPH for drives
DRVMAP      EQU  5E20H          ; Map of CPM drives to apple drives

;******************************************************************
;*                                                                *
;*  Set the common memory segment, code from here on in lives     *
;*  in the language card shared with both the users code and      *
;*  the BDOS                                                      *
;*                                                                *
;******************************************************************  
            ASEG               ; CSeg stuff lives in common memory
            .Z80
            ORG 0DE00H
            ; Externs from SCB.MAC
            EXTRN @COVEC        ; Console out vectors
            EXTRN @CIVEC        ; Console in vectors
            EXTRN @AOVEC        ; Aux out vectors
            EXTRN @AIVEC        ; Aux in vectors
            EXTRN @LOVEC        ; List out vectors
            EXTRN @MLTIO        ; Multi IO flag          
            EXTRN @MXTPA        ; Top of TPA
            ;
            ; BIOS Jump table, address in Axxx range are in main memory
            ; Not generally accessable from users side
            ;
            jp   B_COLD         ; $A623 0  - Cold Start
WARMJP:     jp   B_WBOOT        ; $DEF8 1  - WBOOT - Warm Start
            jp   B_CONIST       ; $DF35 2  - CONST - Console input character read
            jp   B_CONIN        ; $DF42 3  - CONIN - Read console in
            jp   B_CONOUT       ; $DF04 4  - CONOUT - Write console
            jp   B_LIST         ; $DF0E 5  - LIST - Write to list
            jp   B_AUXOUT       ; $DF09 6  - AUXOUT
            jp   B_AUXIN        ; $DF47 7  - AUXIN
            jp   B_HOME         ; $A84C 8  - HOME
            jp   B_SELDSK       ; $A81B 9  - SELDSK
            jp   B_SETTRK       ; $A84E 10 - SETTRK
            jp   B_SETSEC       ; $A86F 11 - SETSEC 
            jp   B_SETDMA       ; $A874 12 - SETDMA
            jp   B_READ         ; $A53A 13 - READ
            jp   B_WRITE        ; $A564 14 - WRITE
            jp   B_LISTST       ; $DF20 15 - LISTST - List Status
            jp   B_SECTRAN      ; $A818 16 - SECTRAN
            jp   B_CONOST       ; $DF16 17 - CONOST - Output status of console
            jp   B_AUXIST       ; $DF3A 18 - AUXIST - Input status of Aux port
            jp   B_AUXOST       ; $DF1B 19 - AUXOST - Output status of Aux port
            jp   B_DEVTBL       ; $DFA4 20 - DEVTBL - Address of char IO Table
            jp   B_DEVINI       ; $DF4F 21 - DEVINI
            jp   B_DRVTBL       ; $A801 22 - DRVTBL - Drive table
            jp   B_MULTIO       ; $A879 23 - MULTIO 
            jp   B_FLUSH        ; $A812 24 - FLUSH
            jp   B_MOVE         ; $DF54 25 - MOVE
            DB   0C9H,0C9H,0C9H ; ret   26 - TIME
            jp   B_SELMEM       ; $DF7A 27 - SELMEM
            jp   B_SETBNK       ; $A814 28 - SETBNK
            jp   B_XMOVE        ; $A805 29 - XMOVE
            jp   B_USERF        ; $DFA8 30 - USERF
            jp   0000H          ;       31 - RESERV1
            jp   0000H          ;       32 - RESERV2
;
; BIOS data that lives in shared memory
;
            DB 07               ; DE63
CURBANK:    DB 0                ; DE64
DMABANK:    DB 0                ; DE65
DMAADDR:    DW 0                ; DE66
SAVEDE:     DW 0                ; DE68
DRVTBL:     DW 0,0,0,0,0,0,0,0
            DW 0,0,0,0,0,0,0,0
            ; Not certain what this is yet
            DS 36               ; DE88
DEVTBL:                         ; DEAE
            DB 'CONSOL',03,00
            DB 'NODEV1',00,00
            DB 'NODEV2',00,00
            DB 'EXTMEM',00,00
            DB 'NODEV4',00,00
            DB 'NODEV5',00,00
            DB 'NODEV6',00,00
            DB 'NODEV7',00,00
            DB 00               ; End of device table
; Unknown at DEEF
            ld   (RDMAINRAM),a
            ld   (WRMAINRAM),a
            jp   XXXXX
;==================================================================
; BIOS Func 1 - WBOOT
; Warm boot CPM, copies CCP into memory and resets vectors.
; Entry
; Nothing
;==================================================================
B_WBOOT:    ld   (RDMAINRAM),a  ; Read from BIOS / BDOS memory
            jp   WBOOT
WBOOT_EXIT: ld   (RDCARDRAM),a  ; Read from aux ram
            jp   CCP          ; Exit to CCP
;==================================================================
; BIOS Func 4 - CONOUT
; Write character to console.   (Screen usually)
; Entry
; C = Character to write
;==================================================================
B_CONOUT:   ld   hl,(@COVEC)    ; Get console out vector
            jr   JPOUT          ; Off to output routine
;==================================================================
; BIOS Func 5 - AUXOUT
; Write character in to aux output. (Serial port usually)
; Entry
; C = Character to write
;==================================================================
B_AUXOUT:   ld   hl,(@AOVEC)    ; Get aux out vector
            jr   JPOUT
;==================================================================
; BIOS Func 6 - LIST
; Write character in to list output. (Printer usually)
; Entry
; C = Character to write
;==================================================================
B_LIST:     ld   hl,(@LOVEC)
JPOUT:      ld   de,VECOUT        ;A8F1
            jr   JPIOFUNC
;==================================================================
; BIOS Func 17 - CONOST
; Get console output status (Screen usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_CONOST:   ld   hl,(@COVEC)
            jr   JPOST
;==================================================================
; BIOS Func 19 - AUXOST
; Get auxiliary output status (Serial port usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_AUXOST:   ld   hl,(@AOVEC)
            jr   JPOST
;==================================================================
; BIOS Func 15 - LISTST
; Get list status (Printer usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_LISTST:   ld   hl,(@LOVEC)
JPOST:      ld   de,VECOST         ;Output status A910
JPIOFUNC:   ld   (RDMAINRAM),a
            jp   IOFUNC
; IO Bios routines come back to here
; Assumption is memory is in main
IOEXIT:     ld   b,a            ; save acc
            ld   a,(CURBANK)    ; Get current bank
            or   a              ; Set flags
            ld   a,b            ; restore acc
            ret  z              ; Go home if it's main bank
            jr   B_MEMCARD      ; Set to Aux card memory
;==================================================================
; BIOS Func 2 - CONIST
; Get console input status (Keyboard usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_CONIST:   ld   hl,(@CIVEC)
            jr   JPIST
;==================================================================
; BIOS Func 18 - AUXIST
; Get auxiliary input status (Serial port usually)
; Entry
; Exit
; A=0 (not ready) A=FF (ready)
;==================================================================
B_AUXIST:   ld   hl,(@AIVEC)
JPIST:      ld   de,VECIST      ;A969
            jr   JPIOFUNC
;==================================================================
; BIOS Func 3 - CONIN
; Get console input, wait for character.
; Entry
; Exit
; A=Character from keyboard
;==================================================================
B_CONIN:    ld   hl,(@CIVEC)
            jr   JPIN
;==================================================================
; BIOS Func 7 - AUXIN
; Get character from auxiliary input (Serial port usually)
; Entry
; Exit
; A=Character from aux input
;==================================================================
B_AUXIN:    ld   hl,(@AIVEC)
JPIN:       ld   de,VECIN      ;A980
            jr   JPIOFUNC
;==================================================================
; BIOS Func 21 - DEVINI
; Initialise device in c register. Called after baud rate changes
; Entry
; C = device number in DEVTBL
; Exit
;==================================================================
B_DEVINI:   ld   de,DEVINI     ;AF12
            jr   JPIOFUNC
;==================================================================
; BIOS Func 25 - MOVE
; Copy memory (sadly wrong order for Z80)
; Also copies across banks if XMOVE has been called.
; Entry
; BC = Number of bytes to move
; DE = Source address
; HL = Dest addresss
; Exit
;==================================================================
B_MOVE:     ld   a,00H          ; 0 if there is XMOVE settings 
            or   a              ; If last call wasn't XMOVE
            jr   nz,MOVEMEM     ; just do the regular mem move
            inc  a              ; if it's xmove this time assume normal 
            ld   (B_MOVE+1),a    ; move next time we get called.
XMOVE_CREG: ld   a,00H          ; XMOVE sets this value to read bank
            ld   (RDMAINRAM),a  ; Assume main memory BIOS/BDOS
            or   a              ; for read bank
            jr   z,XMOVE_BREG   ; Not zero so reading from 
            ld   (RDCARDRAM),a  ; Aux card ram
XMOVE_BREG: ld   a,00H          ; XMOVE sets this value for write bank
            ld   (WRMAINRAM),a  ; Assume main memory BIOS/BDOS 
            or   a              ; for write bank
            jr   z,MOVEMEM      ; Not zero so writing to aux ram
            ld   (WRCARDRAM),a  
MOVEMEM:    ex   de,hl          ; Swap de,hl for CP/M MOVE
            ldir                ; Do the copy
            ex   de,hl          ; swap back and fall thru, to sort out bank.
            ld   a,(CURBANK)    ; Restore back to correct bank
;==================================================================
; BIOS Func 27 - SELMEM
; Set the current memory bank to bank in A register
; Entry
; A=Bank to select
; Exit
;==================================================================
B_SELMEM:   ld   (CURBANK),a    ; Save away the bank requested
B_SELMEM2:  or   a              ; set flag for jumps
            jr   nz,B_MEMCARD   ; Not zero use aux card for the user stuff
            ld   (RDMAINRAM),a  ; Nope we're in BIOS / BDOS land
            ld   (WRMAINRAM),a
            ret
B_MEMCARD:  ld   (RDCARDRAM),a  ; Time for the Users code
            ld   (WRCARDRAM),a
            ret
;==================================================================
; Copy DMA buffer to disk buffer, if zero flag 
; set then copy from main memory bank, otherwise
; it's the auxiliary bank.
;==================================================================
DMA2BUF:    jr   z,DMANOTAUX    ; DMA is from aux bank
            ld   (RDCARDRAM),a  ; set it up.
DMANOTAUX:  ld   de,DISK_BUFF   ; Dest is disk buffer
            ld   hl,(DMAADDR)   ; Source is DMA address
            jr   DMANOTAUX
CPFROMCARD: ld   (RDCARDRAM),a  ; DF9B -
DMADOCOPY:  ldir                ; Do the copy
            ld   (RDMAINRAM),a  ; back to main memory
            ret                 ; Helps with return addresses
;==================================================================
; BIOS Func 20 - DEVTBL
; Get the device table.
; Entry
; Exit
; HL=Address of the table
;==================================================================
B_DEVTBL:   ld   hl,DEVTBL
            ret
;==================================================================
; BIOS Func 30 - USERF
; User functions
; Entry
; Exit
;==================================================================
B_USERF:    ld   (SAVEDE),de
            ld   de,USERF
            jp   JPIOFUNC
;******************************************************************
;*                                                                *
;*  Time to swap segments, code from here on in lives in the      *
;*  shared memory with the BDOS                                   *
;*                                                                *
;******************************************************************            
            ASEG
            ORG 0A400H
SIGNONMSG:  DB ESC,'*',CR,LF
            DB '         ',ESC,'(','  CP/M Plus Version 3.0  for the Apple //e  ',CR,LF,ESC,')'
            DB '         ',ESC,'(','    (C)  CIRTECH 1985       Release 1.07    ',CR,LF,ESC,')'
            DB CR,LF,0
ODDCODE:    DS 20H                  ;A47D - Could be a table here!            
;
;
;
BIOSTK:     DS 058H      ;No idea if right size
BIOSTOS:
;==================================================================
; All of the character device IO routines end up here
; as do the user function calls. Swaps stack to BIOS one
; Entry 
; DE = Routine to call
; HL = Vector for devices for character IO
;==================================================================
IOFUNC:     ld   (WRMAINRAM),a      ; Write to main memory
            ld   (IORESSTK+1),sp    ; Save stack pointer for restore
            ld   sp,BIOSTOS         ; End of BIOSSTK
            push af                 ; Save acc
            xor  a                  ; Ask for main card memory
            call B_SELMEM2          ; Get the memory
            pop  af                 ; Restore accumulator
            ld   (IOCALL+1),de      ; Setup for the call
IOCALL:     call 0000H              ; call de
IORESSTK:   ld   sp,0000H           ; Bring back the stack
            jp   IOEXIT             ; Exit back
;==================================================================
; WBOOT - Warm boot
;   Copy memory from main memory at 0100H into
;   main memory, reset flags and vectors and run CCP
; Entry
; Nothing
; Exit
; Runs CCP
;==================================================================
WBOOT:      ld   (WRCARDRAM),a      ; Write to aux ram
            ld   hl,CCP             ; Copy CCP into aux ram
            ld   d,h
            ld   e,l
            ld   bc,WARMCOPYLEN     ; Get copy length
            ldir                    ; Do the copy
            xor  a                  ; Reset multi io flag?
            ld   (@MLTIO),a         
            ld   hl,(@MXTPA)        ;Top of TPA (aka BDOS)
            ld   (BDOSJP+1),hl      ;set BDOS jump
            ld   a,0C3H             ; JP OpCode
            ld   (WBOOTJP),a        ; Set up jump at 0000
            ld   (BDOSJP),a         ; Set up jump at 0005
            ld   hl,WARMJP          ; Entry in jump Table
            ld   (WBOOTJP+1),hl     ; Store that
            jp   WBOOT_EXIT         ; Jump back out into CCP
;==================================================================
; BIOS Func 13 - READ
; Read in a sector into the DMA address.
; Entry
; Exit
; A = 0 for OK
;     1 for Unrecoverable error
;     FF if media changed.
;==================================================================
B_READ:     ld   (DISKEXIT+1),sp    ; Save stack pointer
            ld   sp,BIOSTOS         ; Set to local stack
            ld   a,01H              ; read operation
            call DISKOPER           ; Do it
            push af
            call GETSECTSZ          ; Get the sector size
            ld   a,(DMABANK)        ; Get the DMA bank
            or   a
            jr   z,READTOMAIN       ; We're in the right one?
            ld   (WRCARDRAM),a      ; Copy into aux card instead
READTOMAIN: ld   de,(DMAADDR)       ; Start the copy into
            ld   hl,DISK_BUFF       ; DMA address from DISK_BUFF
            ldir
            ld   (WRMAINRAM),a      ; Set us back to main ram
            pop  af                 ; Get back error code
DISKEXIT:   ld   sp,0000H           ; Restore stack and home
            ret
;==================================================================
; BIOS Func 14 - WRITE
; Write out a sector.
; Entry
; C = 0 - Write can be deferred (only in BIOS deblocking)
;     1 - Write must be immediate
;     2 - Write can be deferred, no pre-read is necessary.
; Exit
; A = 0 for OK
;     1 for Unrecoverable error
;     2 - Read only error
;     FF if media changed.
;==================================================================
B_WRITE:    ld   (DISKEXIT+1),sp    ; Save stack pointer
            ld   sp,BIOSTOS         ; Stack to BIOS one
            call GETSECTSZ          ; How big are our sectors
            ld   a,(DMABANK)        ; Get the bank
            or   a                  ; Set zero flag
            call DMA2BUF            ; Copy DMA to DISK buffer
            ld   a,02H              ; write operation
            call DISKOPER           ; do disk operation
            jr   DISKEXIT
;=================================================
; Gets the sector size for the current drive
; returns sector size in bc
;=================================================
GETSECTSZ:  ld   bc,0100H           ; Assume it's a Disk ][
            ld   a,(DISK_DRV)       ; Get the drive
            call DRVISDISK2
            ret  z                  ; Go home if it was a Disk II
            ld   bc,0200H           ; Other sector size is 512 bytes
            ret
;=================================================
; Perform a disk operation
;=================================================
DISKOPER:   call 0AA7FH
            ld   (DISK_OP),a
            ld   hl,DISK_ROUT
            ld   (ROUT_6502),hl
            ld   hl,(CARD_Z80)
            ld   (hl),a
            ld   a,(DISK_ERR)
            or   a
            ret  z
            ld   c,07H
DISK_XXX:   ;A5CA            
;   Retry code here?
            ORG  0A623H
B_COLD:                             ; A623
XXXXX:                              ; A6C3
            ORG  0A761H
            DB 'NOCRD ',00,00
            DB 'UNKWN ',00,00
            DB 'DSKII ',00,00
            DB 'COMCD ',0B,00
            DB 'SERCD ',0B,00
            DB 'PRINT ',02,00
            DB '      ',00,00
            DB 'RAMDR ',00,00
            DB 'PDISK ',00,00
            DB 'FDISK ',00,00
            DB 'UNKWN ',00,00
            DB 'PRTCD ',02,00
            DB 'MOUSE ',01,00
            DB 'IODEV ',0B,00
            DB 'MODEM ',0B,00
            DB 'SOUND ',03,00
            DB 'CLOCK ',02,00
            DB 'STORE ',03,00
            DB '80COL ',02,00
            DB 'ATALK ',0B,00
;==================================================================
; BIOS Func 22 - B_DRVTBL 
; Get the drive table, returns the address of the drive table.
; Entry
; Exit 
; HL = DRVTBL
;==================================================================
B_DRVTBL:   ld   hl,DRVTBL
            ret   
;==================================================================
; BIOS Func 29 - B_XMOVE 
; Move memory acrooss banks
; Entry 
; C=source bank
; B=destination bank
; Exit   
;==================================================================
B_XMOVE:    ld   a,c
            ld   (XMOVE_CREG+1),a   ; Save source bank
            ld   a,b
            ld   (XMOVE_BREG+1),a   ; Save destination bank
            xor  a
            ld   (B_MOVE+1),a       ; Flag move as XMOVE
            ret
;==================================================================
; BIOS Func 24 - B_FLUSH 
; Write any pending data to disk
; Only useful if BIOS is doing deblocking
; Entry
; Exit
; A = 0
;==================================================================
B_FLUSH:    xor  a
            ret
;==================================================================
; BIOS Func 28 - B_SETBNK
; Set the bank to use for DMA operations
; Entry
; A = bank to use for DMA
; Exit 
;==================================================================
B_SETBNK:   ld   (DMABANK),a
            ret
;==================================================================
; BIOS Func 16  - SECTRAN
; Translate sector
; Entry
; BC = Logical sector number
; DE = Address of translation table
; Exit
; HL = Physical sector number
;==================================================================
B_SECTRAN:  ld   h,b
            ld   l,c
            ret
;==================================================================
; BIOS Func 9 - SELDSK
; Select the disc drive in register C
; Entry
; C = Drive 0=A, 1=B....
; E = 0 or FFFFH, if Bit 0 is 1 disc has been logged before
;                 if Bit 0 is 0 disc is logged as if new
;                 can cause a disc read to figure out DPH from
;                 boot sector.
; Exit
; HL = Disk parameter Header
;==================================================================
B_SELDSK:   ld   a,c
            ld   (DISK_XXX+1),a  ; A5CA Save drive for disk operation later
            ld   b,0
            ld   hl,DRVMAP
            add  hl,bc
            ld   a,(hl)
            ld   (DISK_DRV),A
            ld   hl,DPHTAB      ; Get DPH for drive
            sla  c              ; Mult by two
            ld   e,c
            ld   d,0
            add  hl,de          ; HL points to DPH for drive
            ld   e,(hl)         ; Get DPH in de
            inc hl
            ld   d,(hl)
            ex   de,hl          ; Put DPH into HL
            ret
;==================================================================
; Drive is disk II 
; Entry
; A = Apple drive code 60=Slot 6 disk 1, E0=slot 6 disk 2
; Exit
; Zero flag set if Disk II drive
;==================================================================
DRVISDISK2: and  07FH           ; Mask off the unit
            rrca                ; Divide by 16
            rrca
            rrca
            rrca
            ld   hl,SLOT_INFO   ; Look up drive type
            ld   e,a 
            ld   d,0
            add  hl,de
            ld   a,(hl)         ; get the drive type
            cp   02H            ; Set zero flag for Disk II drives
            ret
; Unknown at this point
LA848:      adc a,0
            xor b
            ld  h,b
;==================================================================
; BIOS Func 8 - HOME
; Move the current to track 0
; Entry
; Exit
;==================================================================          
B_HOME:     ld  c,0H            ; Set track to zero and fall thru
;==================================================================
; BIOS Func 10 - SETTRK
; Set the track
; Tracks 35,36 and 37 are a bit of a lie on a boot disk
; they're marked as belonging to a file called system.track
; if the disk is a data disk then they're really tracks 0,1,2
; Entry
; BC = Track to set
; Exit
;==================================================================          
B_SETTRK:   ld   (SETTRKEX),sp  ; Save away stack pointer
            ld   sp,BIOSTOS     ; Set bios stack
            ld   a,(DISK_DRV)   ; Get the drive
            call DRVISDISK2     ; See if it's a disk II 
            ld   a,c            ; Set acc to low track bytes
            jr   nz,NOTRKADJ    ; Not disk II so no need to adjust
            cp   35             ; Do we need to wrap track number?
            jr   c,NOTRKADJ     ; Nope so don't adjust
            sub  35             ; Yes we do adjust track
NOTRKADJ:   ld   (DISK_TRKL),a  ; Save away low track
            ld   a,b
            ld   (DISK_TRKH),a  ; And do the high byte
SETTRKEX:   ld   sp,0000H       ; Restore stack pointer
            ret
;==================================================================
; BIOS Func 11 - SETSEC
; Set the sector next disc operation will use
; Size is from the DPH
; Entry
; BC = Sector number
; Exit
;==================================================================            
B_SETSEC:   ld   a,c
            ld   (DISK_SECT),a
            ret
;==================================================================
; BIOS Func 12 - SETDMA
; Set the address next disc operation will use
; Entry
; BC = Address to read or write from
; Exit
;==================================================================
B_SETDMA:   ld   (DMAADDR),bc
            ret
;==================================================================
; BIOS Func 23 - B_MULTIO 
; Multi IO operation setup
; Entry
; Exit
; A = 0
;==================================================================
B_MULTIO:   xor  a
            ret
;==================================================================
; USERF - user function helper
; Entry
; A = routine to call.
; Otherwise BC,DE,HL passed to routine
; Exit
; Unknown
;==================================================================
USERF:      ld   de,(SAVEDE)
            ld   (WRMAINRAM),a
            cp   10
            ret  nc
            sla  a
            push hl
            push bc
            ld   l,a
            ld   h,0
            ld   bc,USERFTBL
            add  hl,bc
            ld   c,(hl)
            inc  hl
            ld   b,(hl)
            ld   (USERFJP),bc
            pop  bc
            pop  hl
USERFJP:    jp   0000H
USERFTBL:   DW   USERF_RET      ; User function 00
            DW   USERF_RET      ; User function 01 
            DW   USERF_RET      ; User function 02
            DW   USERF_RET      ; User function 03
            DW   USERF_04       ; A8A4: 92 AB          
            DW   USERF_05       ; A8A6: BC A8
            DW   USERF_06       ; A8A8: 75 AE
            DW   USERF_07       ; A8AA: 5A AE
            DW   USERF_08       ; A8AC: C0 AB
            DW   USERF_09       ; A8AE: CB A8
            DW   USERF_0A       ; A8B0: DB A8
            DW   USERF_0B       ; A8B2: 34 AE
            DW   USERF_RET      ; User function 0C 
            DW   USERF_RET      ; User function 0D
            DW   USERF_RET      ; User function 0E
            DW   USERF_RET      ; User function 0F
USERF_05:   push de
            ld   de,0FF00H         
            res  7,c
            call 0AE80H
            pop  de
            set  7,c
            jp   0AE80H
USERF_09:            
USERF_0A:            

USERF_RET:
USERF_04:            
USERF_06:            
USERF_07:            
USERF_08:
USERF_0B:            
    ret;
VECOUT:              ;A8F1
VECOST:              ;A910
VECIST:              ;A969
VECIN:               ;A980
DEVINI:              ;AF12
            END
